# -*- org-confirm-babel-evaluate: nil; eval: (setq-local org-structure-template-alist (cons '("hs" . "src haskell :results output") org-structure-template-alist)) -*-
#+STARTUP: overview

book: Programming in Haskell - Graham Hutton

* chapter 1
** 3
#+begin_src haskell :compile yes
  module Main where

  myProduct [] = 1
  myProduct (x:xs) = x * (myProduct xs)

  main :: IO ()
  main =
    putStrLn (show (myProduct [2,3,4]))
#+end_src

#+RESULTS:
: 24

** 4
#+begin_src haskell :compile yes
  module Main where

  qsort []     = []
  qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller
                 where
                   smaller = [a | a <- xs, a <= x]
                   larger  = [b | b <- xs, b > x]

  main :: IO ()
  main =
    putStrLn (show (qsort [2,2,3,1,1]))

#+end_src

#+RESULTS:
| [3 | 2 | 2 | 1 | 1] |
** 5
#+begin_src haskell :compile yes
  module Main where

  qsort []     = []
  qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger
                 where
                   smaller = [a | a <- xs, a < x]
                   larger  = [b | b <- xs, b > x]

  main :: IO ()
  main =
    putStrLn (show (qsort [2,2,3,1,1]))

#+end_src

#+RESULTS:
| [1 | 2 | 3] |

At first I thought it would remove only the duplicates of the first element of the list. But reading the output of the program, I realise that it will remove duplicates of the first element of each sublist processed.

#+begin_example
[2, 2, 3, 1, 1]

[1, 1] ++ [2] ++ [3]

([] ++ [1] ++ []) ++ [2] ++ [3]

[1] ++ [2] ++ [3]

[1, 2] ++ [3]

[1, 2, 3]
#+end_example

* chapter 2
** 3
#+begin_src haskell :compile yes :results output
  module Main where

  n = a `div` (length xs)
    where
      a  = 10
      xs = [1,2,3,4,5]

  main :: IO ()
  main =
    putStrLn (show n)
#+end_src

#+RESULTS:
: 2

* chapter 3
** 3
#+begin_src haskell :results none
  second :: [a] -> a
  swap :: (t1, t2) -> (t2, t1)
  pair x y :: t1 -> t2 -> (t1, t2)
  double x :: Num a => a -> a
  palindrome xs :: [a] -> Bool
  twice :: (t1 -> t2) -> t1 -> t2
#+end_src

** 4
#+begin_src haskell :results output
  second xs = head (tail xs)
  :type second
#+end_src

#+RESULTS:
: second :: [a] -> a

#+begin_src haskell :results output
  swap (x,y) = (y,x)
  :type swap
#+end_src

#+RESULTS:
: swap :: (b, a) -> (a, b)

#+begin_src haskell :results output
  pair x y = (x,y)
  :type pair
#+end_src

#+RESULTS:
: pair :: a -> b -> (a, b)

#+begin_src haskell :results output
  double x = x * 2
  :type double
#+end_src

#+RESULTS:
: double :: Num a => a -> a

#+begin_src haskell :results output
  palindrome xs = reverse xs == xs
  :type palindrome
#+end_src

#+RESULTS:
: palindrome :: Eq a => [a] -> Bool
❌
Forgot to take into account that elements of the list have to have a type that is instance of =Eq=.

#+begin_src haskell :results output
  twice f x = f (f x)
  :type twice
#+end_src

#+RESULTS:
: twice :: (t -> t) -> t -> t

❌
If =f= is going to be applied to =f x=, the type of the output of =f= necessarily has to be the same as the input.

** 5
Function types encode the types of the inputs and outputs. It would be wrong to say that a function that doubles numbers is the same as a function that squares numbers, even though they have the same types and quantity of inputs and outputs. It would also be wrong to say that a function that computes double of numbers by means of multiplication is different from a function that computes double of numbers by means of addition. It would be feasible if the type system could infer the exact elements of the inputs and the exact elements of the output of a function, not only their types.

* chapter 4
** 1
#+begin_src haskell :results output
  halve ns = let n = length ns `div` 2 in (take n ns, drop n ns)

  halve [1,2,3,4,5,6]

  halve [1,2,3]

  :type halve
#+end_src

#+RESULTS:
: ([1,2,3],[4,5,6])
: ([1],[2,3])
: halve :: [a] -> ([a], [a])
** 2
*** a
#+begin_src haskell :results output
  third ns = head (tail (tail ns))

  third [1,2,3]

  :type third
#+end_src

#+RESULTS:
: 3
: third :: [a] -> a

*** b
#+begin_src haskell :results output
  third ns = ns !! 2

  third [4,5,6]

  :type third
#+end_src

#+RESULTS:
: 6
: third :: [a] -> a

*** c
#+begin_src haskell :results output
  third (f:(s:(t:xs))) = t

  third [7,8,9]

  :type third
#+end_src

#+RESULTS:
: 9
: third :: [a] -> a
** 3
*** a
#+begin_src haskell :results output
  safetail ns = if null ns then ns else tail ns

  safetail []

  safetail [1]

  safetail [1,2]

  :type safetail
#+end_src

#+RESULTS:
: []
: []
: [2]
: safetail :: [a] -> [a]

*** b
#+begin_src haskell :results output
  :{
  safetail ns | null ns   = ns
              | otherwise = tail ns
  :}

  safetail []

  safetail [1]

  safetail [1,2]

  :type safetail    
#+end_src

#+RESULTS:
: []
: []
: [2]
: safetail :: [a] -> [a]

*** c
#+begin_src haskell :results output
  :{
  safetail []     = []
  safetail (x:xs) = xs
  :}

  safetail []

  safetail [7]

  safetail [7,8]

  :type safetail    
#+end_src

#+RESULTS:
: []
: []
: [8]
: safetail :: [a] -> [a]
** 4
#+begin_src haskell
  True  || True  = True
  False || True  = True
  True  || False = True
  False || False = False
#+end_src

#+begin_src haskell
  True || _    = True
  _    || True = True
  _    || _    = False
#+end_src

#+begin_src haskell
  False ||     b = b
  b     || False = b
#+end_src

#+begin_src haskell
  b || c | b == False = c
         | otherwise  = True
#+end_src

#+begin_src haskell :results output
  :{
  True  % True  = True
  False % True  = True
  True  % False = True
  False % False = False
  :}

  True % False
  False % False
#+end_src

#+RESULTS:
: True
: False
** 5
#+begin_src haskell :results output
  a % b = if a then b else if b then a else False

  True % True
  True % False
  False % True
  False % False
#+end_src

#+RESULTS:
: True
: False
: False
: False
** 6
#+begin_src haskell :results output
n  a % b = if a then b else False

  True % True
  True % False
  False % True
  False % False
#+end_src

#+RESULTS:
: True
: False
: False
: False
** 7
#+begin_src haskell :results output
  :{
  mult :: Int -> Int -> Int -> Int
  mult = \x -> (\y -> (\z -> x*y*z))
  :}

  mult 2 3 4
#+end_src

#+RESULTS:
: 24
** 8
#+begin_src haskell :results output
  :{
  decimalDigits n | n == 0    = 1
                  | otherwise = floor (1 + (logBase 10 (abs n)))
  :}

  decimalDigits 1234
  :type decimalDigits
#+end_src

#+RESULTS:
: 4
: decimalDigits
:   :: (RealFrac a1, Integral a2, Floating a1) => a1 -> a2

#+begin_src haskell :results output
  luhnDouble n = let twon = (2 * n) in if twon > 9 then twon - 9 else twon

  luhnDouble 3

  luhnDouble 6
#+end_src

#+RESULTS:
: 6
: 3

#+begin_src haskell :results output
  luhnDouble n = let twon = (2 * n) in if twon > 9 then twon - 9 else twon
    
  luhn a b c d = sum [luhnDouble a, b, luhnDouble c, d] `mod` 10 == 0

  luhn 1 7 8 4

  luhn 4 7 8 3

  :type luhn
#+end_src

#+RESULTS:
: True
: False
: luhn :: Integral a => a -> a -> a -> a -> Bool

* chapter 5
** 1
#+begin_src haskell :results output
  sum [x^2 | x <- [1..100]]
#+end_src

#+RESULTS:
: 338350
** 2
#+name: grid
#+begin_src haskell :results output
  :{
  grid :: Int -> Int -> [(Int, Int)]
  grid x y = [(x', y') | x' <- [0..x], y' <- [0..y]]
  :}

  grid 1 2
#+end_src

#+RESULTS:
: [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
** 3
#+begin_src haskell :results output :noweb yes
  <<grid>>
  square n = [(x, y) | (x, y) <- grid n n, x /= y]

  square 2
#+end_src

#+RESULTS:
: [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
: [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
** 4
#+begin_src haskell :results output
  replicate n e = [e | _ <- [1..n]]

  replicate 3 True
#+end_src

#+RESULTS:
: [True,True,True]
** 5
#+begin_src haskell :results output
  :{
  pyths :: Int -> [(Int,Int,Int)]
  pyths n = [(x,y,z) | x <- xs, y <- xs, z <- xs, x^2 + y^2 == z^2]
             where xs = [1..n]
  :}

  pyths 10
#+end_src

#+RESULTS:
: [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
** 6
#+begin_src haskell :results output
  factors n = [x | x <- [1..n], n `mod` x == 0]

  perfect n = n == (sum (init (factors n)))

  perfects n = [x | x <- [1..n], perfect x]

  perfects 500
#+end_src

#+RESULTS:
: [6,28,496]
** 7
#+begin_src haskell :results output
  [(x,y) | x <- [1,2], y <- [3, 4]]
#+end_src

#+RESULTS:
: [(1,3),(1,4),(2,3),(2,4)]
?
** 8
#+begin_src haskell :results output
  find k t = [v | (k',v) <- t, k == k']

  -- positions x xs = [i | (x',i) <- zip xs [0..], x == 'x]

  positions x xs = find x (zip xs [0..])

  positions False [True, False, True, False]

#+end_src

#+RESULTS:
: [1,3]

** 9
#+begin_src haskell :results output
  scalarproduct xs ys = sum [x * y | (x, y) <- zip xs ys]

  scalarproduct [1,2,3] [4,5,6]
#+end_src

#+RESULTS:
: 32

* chapter 6
** 2
#+begin_src haskell :results output
  :{
  sumDown 0 = 0
  sumDown n = n + sumDown (n - 1)
  :}

  sumDown 3
#+end_src

#+RESULTS:
: 6
** 3
#+begin_src haskell :results output
  :{
  a % 1 = a
  a % b = a * (a % (b - 1))
  :}

  2 % 10
  2 % 3
#+end_src

#+RESULTS:
: 1024
: 8

#+begin_example
  2 % 3
=   { applying % }
  2 * ( 2 % 2 )
=   { applying % }
  2 * ( 2 * ( 2 % 1 ))
=   { applying % }
  2 * ( 2 * ( 2 ))
=   { applying * }
  2 * ( 4 )
=   { applying * }
  8
#+end_example
** 4
#+begin_src haskell :results output
  :{
  euclid a b | a == b    = a
             | a < b     = euclid a (b - a)
             | otherwise = euclid (a - b) b
  :}

  euclid 6 27
#+end_src

#+RESULTS:
: 3
** 6
*** a
#+begin_src haskell :results output
  :{
  and [x]    = x
  and (x:xs) = x && and xs
  :}

  and [True, True, True]
  and [True, True, False]
#+end_src

#+RESULTS:
: True
: False
*** b
#+begin_src haskell :results output
  :{
  concat []     = []
  concat (x:xs) = x ++ concat xs
  :}

  concat [[1,2],[3,4]]
#+end_src

#+RESULTS:
: [1,2,3,4]
*** c
#+begin_src haskell :results output
  :{
  replicate 0 a = []
  replicate n a = [a] ++ replicate (n - 1) a
  :}

  replicate 10 'a'
#+end_src

#+RESULTS:
: aaaaaaaaaa
*** e
#+begin_src haskell :results output
  :{
  elem e []     = False
  elem e (x:xs) = e == x || elem e xs
  :}

  elem 5 [1..10]
  elem 6 [1..5]
#+end_src

#+RESULTS:
: True
: False
** 7
#+begin_src haskell :results output
  :{
  merge []     []     = []
  merge []     (y:ys) = (y:ys)
  merge (x:xs) []     = (x:xs)
  merge (x:xs) (y:ys) | x <= y    = [x,y] ++ merge xs ys
                      | otherwise = [y,x] ++ merge xs ys
  :}

  merge [2,5,6] [1,3,4]
#+end_src

#+RESULTS:
: [1,2,3,5,4,6]
** 8
#+begin_src haskell :results output
  :{
  merge []     []     = []
  merge []     (y:ys) = (y:ys)
  merge (x:xs) []     = (x:xs)
  merge (x:xs) (y:ys) | x <= y    = [x] ++ merge xs (y:ys) -- !
                      | otherwise = [y] ++ merge (x:xs) ys -- !
  :}

  :{
  halve lst = (take l lst, drop l lst)
    where l = (length lst) `div` 2
  :}

  :{
  msort []  = []
  msort [x] = [x]
  msort lst = merge (msort a) (msort b)
    where
      (a,b) = halve lst
  :}

  merge [6] [3]
  msort (reverse [1..10])
#+end_src

#+RESULTS:
: [3,6]
: [1,2,3,4,5,6,7,8,9,10]

Had to look merge sort on Wikipedia.
** 9
*** c
#+begin_src haskell :results output
  -- 1
  -- last :: [a] -> a
  -- 2,3,4,5
  :{
  last [a]    = a
  last (a:ax) = last ax
  :}

  last [1..10]
#+end_src

#+RESULTS:
: 10

* chapter 7

** 1
#+begin_src haskell :results output
  mapFilter f p lst = [f x | x <- lst, p x]

  mapFilter' f p lst = map f (filter p lst)

  mapFilter (1+) odd [1..10] == mapFilter' (1+) odd [1..10]
#+end_src

#+RESULTS:
: True

** 2

*** d
#+begin_src haskell :results output
  :{
  myDropWhile p []  = []
  myDropWhile p (x:xs) | p x       = myDropWhile p xs
                       | otherwise = (x:xs)
  :}

  myDropWhile odd [1,3,5,7,8,9,10]
#+end_src

#+RESULTS:
: [8,9,10]

** 3
#+begin_src haskell :results output
  myMap f lst = foldr ((:) . f) [] lst
  myMap (2*) [1..10] == map (2*) [1..10]

  myFilter p lst = foldr (\y -> \z -> if p y then y:z else z) [] lst
  myFilter odd [1..10] == filter odd [1..10]
#+end_src

#+RESULTS:
: True
: True

** 4
#+begin_src haskell :results output
  dec2int lst = foldl (\y z -> y*10+z) 0 lst

  dec2int [2,3,4,5]
#+end_src

#+RESULTS:
: 2345

** 5
#+begin_src haskell :results output
  myCurry f = \x y -> f (x, y)
  myUncurry f = \(x, y) -> f x y

  myCurry (\(x, y) -> x + y) 1 2
  myUncurry (+) (1,2)
#+end_src

#+RESULTS:
: 3
: 3

** 9
#+begin_src haskell :results output
  :{
  altMap f g []     = []
  altMap f g (x:xs) = f x : altMap g f xs
  :}

  altMap (+10) (+100) [0,1,2,3,4]
#+end_src

#+RESULTS:
: [10,101,12,103,14]

* chapter 8

** 1
#+begin_src haskell :results output
  data Nat = Zero | Succ Nat

  :{
  nat2int :: Nat -> Int
  nat2int Zero     = 0
  nat2int (Succ n) = 1 + nat2int n
  :}

  :{
  int2nat :: Int -> Nat
  int2nat 0 = Zero
  int2nat n = Succ (int2nat (n-1))
  :}

  :{
  add :: Nat -> Nat -> Nat
  add Zero n = n
  add (Succ m) n = Succ (add m n)
  :}

  :{
  mult :: Nat -> Nat -> Nat
  mult Zero        _           = Zero
  mult _           Zero        = Zero
  mult (Succ Zero) n           = n
  mult m           (Succ Zero) = m
  mult (Succ m) n              = add n (mult m n)
  :}

  nat2int (mult (Succ (Succ Zero)) (Succ (Succ (Succ Zero))))

  nat2int (mult Zero (Succ (Succ (Succ Zero))))

  nat2int (mult (Succ Zero) (Succ (Succ (Succ Zero))))

  nat2int (mult (Succ (Succ (Succ Zero))) (Succ (Succ (Succ Zero))))
#+end_src

#+RESULTS:
: 6
: 0
: 3
: 9

** 2
#+begin_src haskell :results output
  data Tree a = Leaf a | Node (Tree a) a (Tree a)

  :{
  t :: Tree Int
  t = Node (Node (Leaf 1) 3 (Leaf 4)) 5
           (Node (Leaf 6) 7 (Leaf 9))
  :}

  :{   
  occurs :: Ord a => a -> Tree a -> Bool
  occurs x (Leaf y)                         = compare x y == EQ
  occurs x (Node l y r) | compare x y == EQ = True
                        | compare x y == LT = occurs x l
                        | otherwise         = occurs x r
  :}

  occurs 1 t
  occurs 11 t
#+end_src

#+RESULTS:
: True
: False

No idea.

** 3
#+name: balanced
#+begin_src haskell :results output
  data Tree a = Leaf a | Node (Tree a) (Tree a)

  :{
  numberOfLeaves :: Tree a -> Int
  numberOfLeaves (Leaf _)   = 1
  numberOfLeaves (Node l r) = numberOfLeaves l + numberOfLeaves r
  :}

  :{
  balanced :: Tree a -> Bool
  balanced (Leaf _)   = True
  balanced (Node l r) =  abs (subtract nl nr) <= 1
    where
      nl = numberOfLeaves l
      nr = numberOfLeaves r
  :}
#+end_src

#+RESULTS: balanced

#+begin_src haskell :results output :noweb yes
  <<balanced>>
  :{
  shouldBeBalanced :: Tree Int
  shouldBeBalanced = Node
    (Node (Leaf 1) (Leaf 2))
    (Node (Leaf 3) (Leaf 4))
  :}

  balanced shouldBeBalanced

  :{
  shouldNotBeBalanced :: Tree Int
  shouldNotBeBalanced = Node
    (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))
    (Leaf 4)
  :}

  balanced shouldNotBeBalanced
#+end_src

#+RESULTS:
: True
: False

** 4
#+begin_src haskell :results output :noweb yes
  <<balanced>>


  :{
  halve :: [a] -> ([a], [a])
  halve lst = (take n lst, drop n lst)
    where
      n = (length lst) `div` 2
  :}

  :{
  balance :: [a] -> Tree a
  balance [x] = Leaf x
  balance lst = Node (balance l) (balance r)
    where
      (l, r) = halve lst
  :}

  balanced $ balance [1,2,3,4,5]
  balanced $ balance [1,2,3,4]
#+end_src

#+RESULTS:
: True
: True

** 5
#+name: folde
#+begin_src haskell :results output
  data Expr = Val Int | Add Expr Expr

  :{
  folde :: (Int -> a) -> (a -> a -> a) -> Expr -> a
  folde f g (Val n) = f n
  folde f g (Add m n) = g (folde f g m)
                          (folde f g n)
  :}
#+end_src

** 6
#+begin_src haskell :results output :noweb yes
  <<folde>>

  :{
  eval :: Expr -> Int
  eval = folde id (+)
  :}

  :{
  size :: Expr -> Int
  size = folde (\x -> 1) (+)
  :}

  let exp = (Add (Val 1) (Add (Val 2) (Val 3)))

  size exp
  eval exp
#+end_src

#+RESULTS:
: 3
: 6

** 7
#+begin_src haskell :results output
  :{
  instance Eq a => Eq (Maybe a) where
    (Just x) == (Just y) = x == y
    _        == _        = False
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-29: error:
:     Duplicate instance declarations:
:       instance Eq a => Eq (Maybe a) -- Defined at <interactive>:4:10
:       instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’

#+begin_src haskell :results output
  :{
  instance Eq a => Eq [a] where
    [] == []         = True
    [] == _          = False
    _  == []         = False
    (x:xs) == (y:ys) = x == y && xs == ys
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-23: error:
:     Duplicate instance declarations:
:       instance Eq a => Eq [a] -- Defined at <interactive>:4:10
:       instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’

** 8
#+begin_src haskell :results output
  eval s (Or p q)    = eval s p || eval s q
  eval s (Equiv p q) = eval s p == eval
#+end_src

* chapter 9
#+name: eval
#+begin_src haskell :results output
  data Op = Add | Sub | Mul | Div

  :{
  instance Show Op where
    show Add = "+"
    show Sub = "-"
    show Mul = "*"
    show Div = "/"
  :}

  :{
  valid :: Op -> Int -> Int -> Bool
  valid Add _ _ = True
  valid Sub x y = x > y
  valid Mul _ _ = True
  valid Div x y = x `mod` y == 0
  :}

  :{
  apply :: Op -> Int -> Int -> Int
  apply Add x y = x + y
  apply Sub x y = x - y
  apply Mul x y = x * y
  apply Div x y = x `div` y
  :}

  data Expr = Val Int | App Op Expr Expr

  :{
  instance Show Expr where
    show (Val n)     = show n
    show (App o l r) = brak l ++ show o ++ brak r
      where
        brak (Val n) = show n
        brak e       = "(" ++ show e ++ ")"
  :}

  show (App Add (Val 1) (App Mul (Val 2) (Val 3)))

  :{
  values :: Expr -> [Int]
  values (Val n) = [n]
  values (App _ l r) = values l ++ values r
  :}

  :{
  eval :: Expr -> [Int]
  eval (Val n) = [n | n > 0]
  eval (App o l r) = [apply o x y | x <- eval l,
                                    y <- eval r,
                                    valid o x y]
  :}

  eval (App Add (Val 2) (Val 3))
  eval (App Sub (Val 2) (Val 3))
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []

#+name: choices
#+begin_src haskell :results output
  :{
  subs :: [a] -> [[a]]
  subs []     = [[]]
  subs (x:xs) = yss ++ map (x:) yss
                where yss = subs xs
  :}

  :{
  interleave :: a -> [a] -> [[a]]
  interleave x [] = [[x]]
  interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)
  :}

  :{
  perms :: [a] -> [[a]]
  perms [] = [[]]
  perms (x:xs) = concat (map (interleave x) (perms xs))
  :}

  subs [1,2,3]

  :{
  choices :: [a] -> [[a]]
  choices = concat . map perms . subs
  :}
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]

#+begin_example
subs [1,2,3]
= (applying subs)
yss ++ map (1:) yss
where yss = subs [2,3]
= (applying subs [2,3])
yss ++ map (2:) yss
where yss = subs [3]
= (applying subs [3])
yss ++ map (3:) yss
where yss = subs []
= (applying subs [])
yss ++ map (3:) yss
where yss = [[]]
= (replacing yss for [[]])
[[]] ++ map (3:) [[]]
= (applying map)
[[]] ++ [[3]]
= (applying ++)
[[],[3]]
= (replacing yss for [[],[3]]
[[],[3]] ++ map (2:) [[],[3]]
= (applying map)
[[],[3]] ++ [[2],[2,3]]
= (applying ++)
[[],[3],[2],[2,3]]
= (replacing yss for [[],[3],[2],[2,3]])
[[],[3],[2],[2,3]] ++ map (1:) [[],[3],[2],[2,3]]
= (applying map)
[[],[3],[2],[2,3]] ++ [[1],[1,3],[1,2],[1,2,3]]
= (applying ++)
[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
#+end_example

#+begin_example
interleave 1 [2,3,4]
= (applying interleave)
(1:2:[3,4]) : map (2:) (interleave 1 [3,4])
= (applying interleave)
(1:3:[4]) : map (3:) (interleave 1 [4])
= (applying interleave)
(1:4:[]) : map (4:) (interleave 1 [])
= (applying interleave)
(1:4:[]) : map (4:) [[1]]
= (applying map)
(1:4:[]) : [[4,1]]
= (applying :)
[[1,4],[4,2]]
= (replacing (interleave 1 [4]) for [[1,4],[4,2]])
(1:3:[4]) : map (3:) [[1,4],[4,2]]
= (applying map)
(1:3:[4]) : [[3,1,4],[3,4,2]]
= (applying :)
[[1,3,4],[3,1,4],[3,4,2]]
= (replacing (interleave 1 [3,4]) for [[1,3,4],[3,1,4],[3,4,2]]
[1,2,3,4] : map (2:) [[1,3,4],[3,1,4],[3,4,2]]
= (applying map)
[1,2,3,4] : [[2,1,3,4],[2,3,1,4],[2,3,4,2]]
= (applying :)
[[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,2]]
#+end_example

#+begin_example
perms [1,2,3]
= (applying perms)
perms (1:[2,3]) = concat (map (interleave 1) (perms [2,3]))
= (applying perms)
perms (2:[3]) = concat (map (interleave 2) (perms [3]))
= (applying perms)
perms (3:[]) = concat (map (interleave 3) (perms []))
= (applying perms)
perms (3:[]) = concat (map (interleave 3) [[]])
= (applying map)
perms (3:[]) = concat [[[3]]]
= (applying concat)
perms (3:[]) = [[3]]
= (replacing (perms [3]) for [[3]])
perms (2:[3]) = concat (map (interleave 2) [[3]])
= (applying map)
perms (2:[3]) = concat [[[2,3],[3,2]]]
= (applying concat)
perms (2:[3]) = [[2,3],[3,2]]
= (replacinng (perms [2,3]) for [[2,3],[3,2]])
perms (1:[2,3]) = concat (map (interleave 1) [[2,3],[3,2]])
= (applying map)
perms (1:[2,3]) = concat [[[1,2,3],[2,1,3],[2,3,1]],[[1,3,2],[3,1,2],[3,2,1]]]
= (applying concat)
perms (1:[2,3]) = [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
#+end_example

#+begin_example
choices [1,2,3]
= (applying choices)
concat . map perms . subs [1,2,3]
= (applying subs)
concat . map perms [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
= (applying map)
concat . [[[]],[[3]],[[2]],[[2,3],[3,2]],[[1]],[[1,3],[3,1]],[[1,2],[2,1]],[[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]]
= (applying concat)
[[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
#+end_example

#+name: solution
#+begin_src haskell :results output :noweb yes
  <<eval>>
  <<choices>>
  :{
  solution :: Expr -> [Int] -> Int -> Bool
  solution e ns n =
    elem (values e) (choices ns) && eval e == [n]
  :}

  solution (App Mul (App Add (Val 1) (Val 50)) (App Sub (Val 25) (Val 10))) [1,3,7,10,25,50] 765
#+end_src

#+RESULTS: solution
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

#+begin_src haskell :results output :noweb yes :tangle yes :comments noweb
  <<solution>> 
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

Performance testing was done by tangling this file, then changing the generated file according to the book.

#+begin_src bash
  ghc -O2 countdown.hs > /dev/null
  (time (./countdown > /dev/null)) 2> countdown-time.txt
  cat countdown-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m7.600s |
| user | 0m7.579s |
| sys  | 0m0.020s |

#+begin_src bash
  ghc -O2 countdown-v2.hs > /dev/null
  (time (./countdown-v2 > /dev/null)) 2> countdown-v2-time.txt
  cat countdown-v2-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m0.483s |
| user | 0m0.462s |
| sys  | 0m0.020s |

#+begin_src bash
  ghc -O2 countdown-v3.hs > /dev/null
  (time (./countdown-v3 > /dev/null)) 2> countdown-v3-time.txt
  cat countdown-v3-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m0.078s |
| user | 0m0.074s |
| sys  | 0m0.004s |

#+begin_src bash
  rm countdown{,-v2,-v3}{,.hi,.o}
#+end_src

#+RESULTS:

** 1
#+begin_src haskell :results output
  :{
  subs :: [a] -> [[a]]
  subs []     = [[]]
  subs (x:xs) = yss ++ map (x:) yss
                where yss = subs xs
  :}

  :{
  interleave :: a -> [a] -> [[a]]
  interleave x [] = [[x]]
  interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)
  :}

  :{
  perms :: [a] -> [[a]]
  perms [] = [[]]
  perms (x:xs) = concat (map (interleave x) (perms xs))
  :}

  :{
  choices :: [a] -> [[a]]
  choices (x:xs) = [p | s <- subs (x:xs), p <- perms s]
  :}

  choices [1,2,3]
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]

Reminder for list comprehensions: a generator can use values generated to its left.

** 2
List $a$ is chosen from list $b$ if the elements of $a$ are a subset of the elements of $b$, assuming that elements don't repeat in either $a$ or $b$.
#+begin_src haskell :results output :noweb yes
  <<choices>>
  :{
  removeFirst el [] = []
  removeFirst el (x:xs) | el == x   = xs
                        | otherwise = x : removeFirst el xs
  :}

  removeFirst 3 [1..10] ++ [3]

  :{
  isChoice :: Eq a => [a] -> [a] -> Bool
  isChoice []     lst = True
  isChoice (x:xs) lst = removeFirst x lst /= lst && isChoice xs lst
  :}

  isChoice [3,2] [1,2,3]
  isChoice [3,4] [1,2,3]
  isChoice [3,4] [1,2,3,4]
  isChoice [1]   []

  let _choices = choices [1,2,3]
  all (\x -> isChoice x [1,2,3]) _choices
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: [1,2,4,5,6,7,8,9,10,3]
: True
: False
: True
: False
: True

** 3
Couldn't come up with a more elegant solution.
#+begin_src haskell :results output :noweb yes
  <<solution>>

  :{
  _split :: [a] -> [([a],[a])]
  _split []     = []
  _split [_]    = []
  _split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- _split xs]
  -- split (x:xs) = ([],(x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
  -- split (x:xs) = [([],(x:xs))] ++ ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  split lst = [([],lst)] ++ (_split lst) ++ [(lst,[])]

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  -- exprs [1,2]
#+end_src

The code block above, with the last line uncommented, does not output a result after a long time and uses a lot of memory, do not run it.

#+begin_example
exprs [1,2,3,4]
= (applying exprs)
[e | (ls, rs) <- split [1,2,3,4],
     l        <- exprs ls,
     r        <- exprs rs,
     e        <- combine l r]
= (applying split)
[([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
= (values of ls)
[[],[1],[1,2],[1,2,3],[1,2,3,4]]
= (values of rs)
[[1,2,3,4],[2,3,4],[3,4],[4],[]]
= (applying exprs ls)
[[], [Val 1],[App Add (Val 1) (Val 2) ...],[1,2,3],[1,2,3,4]]
#+end_example

#+begin_src haskell :results output
[(i,j) | i <- [[],[1],[2,3],[4,5,6]], j <- [[4,5,6],[2,3],[1],[]]]
#+end_src

#+RESULTS:
: [([],[4,5,6]),([],[2,3]),([],[1]),([],[]),([1],[4,5,6]),([1],[2,3]),([1],[1]),([1],[]),([2,3],[4,5,6]),([2,3],[2,3]),([2,3],[1]),([2,3],[]),([4,5,6],[4,5,6]),([4,5,6],[2,3]),([4,5,6],[1]),([4,5,6],[])]

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  [e | l <- [(Val 1)], r <- [(Val 2)], e <- combine l r]
  [e | l <- [(Val 1)], r <- [(Val 2), (Val 3)], e <- combine l r]
  [e | l <- [(Val 1)], r <- [(Val 2), []], e <- combine l r]
#+end_src

#+RESULTS:
#+begin_example
1+(2*3)
[5]
[]
[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
True
[1+2,1-2,1*2,1/2]
[1+2,1-2,1*2,1/2,1+3,1-3,1*3,1/3]
<interactive>:102:37-38: error:
    • Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
    • In the expression: []
      In the expression: [(Val 2), []]
      In a stmt of a list comprehension: r <- [(Val 2), []]
#+end_example

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  _split :: [a] -> [([a],[a])]
  _split []     = []
  _split [_]    = []
  _split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- _split xs]
  -- split (x:xs) = ([],(x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
  -- split (x:xs) = [([],(x:xs))] ++ ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  split lst = [([],lst)] ++ (_split lst) ++ [(lst,[])]

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  -- exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  exprs [1,2]
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True
: *** Exception: stack overflow

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  -- exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  exprs [1,2,3]
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True
: [1+(2+3),1-(2+3),1*(2+3),1/(2+3),1+(2-3),1-(2-3),1*(2-3),1/(2-3),1+(2*3),1-(2*3),1*(2*3),1/(2*3),1+(2/3),1-(2/3),1*(2/3),1/(2/3),(1+2)+3,(1+2)-3,(1+2)*3,(1+2)/3,(1-2)+3,(1-2)-3,(1-2)*3,(1-2)/3,(1*2)+3,(1*2)-3,(1*2)*3,(1*2)/3,(1/2)+3,(1/2)-3,(1/2)*3,(1/2)/3]



The function =split= modified to return pairs containing the empty list wouldn't fit with the other functions since =combine= expects arguments of the type =Expr= and =exprs= cannot output a non-empty list if its input is the empty list. I don't understand why =exprs= does not apply =combine= to the empty list and throws an error before running out of stack memory. Conceptually, I cannot make sense of =split= returning the empty list because then =combine= would return incomplete expressions. =combine= working with incomplete expressions is not necessary in our case because the game requires a predetermined list of numbers, but it could be useful for generalizing our program.

** 4
#+begin_src haskell :results output :noweb yes
  <<eval>>
  <<choices>>
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  allExpressions = concat (map exprs (choices [1,3,7,10,25,50]))
  "number of possible expressions: " ++ show (length allExpressions)
  validExpressions = filter (\x -> x /= []) (map eval allExpressions)
  "number of valid expressions: " ++ show (length validExpressions)
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: number of possible expressions: 33665406
: number of valid expressions: 4672540

* chapter 10
** 1
#+begin_src haskell :compile yes :results output
  myPutStr lst = sequence_ [putChar x | x <- lst]

  main = myPutStr "Hello, World!"
#+end_src

#+RESULTS:
: Hello, World!
** 2
#+begin_src haskell :compile yes :results output
  type Board = [Int]

  putBoardRow :: Int -> Int -> IO ()
  putBoardRow x y = putStrLn ((show x) ++ ": " ++ (replicate y '*'))

  _putBoard :: Int -> Board -> IO ()
  _putBoard n [x]    = putBoardRow n x
  _putBoard n (x:xs) = do putBoardRow n x
                          _putBoard (n + 1) xs

  putBoard :: Board -> IO ()
  putBoard lst = _putBoard 1 lst

  main = do putBoard (reverse [1..10])
            putBoard [1..10]
#+end_src

#+RESULTS:
#+begin_example
1: **********
2: *********
3: ********
4: *******
5: ******
6: *****
7: ****
8: ***
9: **
10: *
1: *
2: **
3: ***
4: ****
5: *****
6: ******
7: *******
8: ********
9: *********
10: **********
#+end_example
** 3
#+begin_src haskell :compile yes :results output
  type Board = [Int]

  putBoard :: Board -> IO ()
  putBoard b = sequence_ [putStrLn ((show x) ++ ": " ++ (replicate y '*')) | (x, y) <- zip [1..] b]

  main = putBoard (reverse [1..10])
#+end_src

#+RESULTS:
#+begin_example
1: **********
2: *********
3: ********
4: *******
5: ******
6: *****
7: ****
8: ***
9: **
10: *
#+end_example
** 4
[[file:adder.hs]]
** 5
[[file:adder-v2.hs]]
** 6
[[file:readLine.hs]]

* chapter 11
** 1
[[file:tictactoe-v3.hs]]
** 2
[[file:tictactoe-v4.hs]]
You can quickly see that the computer chooses different positions by playing positions 0 then 8.
** 3
[[file:tictactoe-v6.hs]]
This AI is dumb. I tried to write a version that checks if a tree can lead to victory, but I couldn't get it to compile:
[[file:tictactoe-v5.hs]]
* chapter 12
** Functors
Functors: class of types that support mapping a function over each element of a data structure. The concept can be represented in Haskell with the following
#+begin_src haskell :eval never
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src
Functors are required to satisfy two equational laws:
#+begin_example
fmap id      = id
fmap (g . h) = fmap g . fmap h
#+end_example
=fmap= preserves the identity function, applying it to the identity function returns the same function.
=fmap= preserves composition, applying it to the composition of two functions gives the same result as applying =fmap= to the two functions separately and them composing.

One implementation of the type class for lists that violates these laws is:
#+begin_src haskell :eval never
instance Functor [] where
   -- fmap :: (a -> b) -> f a -> f b
   fmap g []     = []
   fmap g (x:xs) = fmap g xs ++ [g x]
#+end_src

#+begin_example
> fmap id [1,2]
[2,1]
> id [1,2]
[1,2]
> fmap (not . even) [1,2]
[False,True]
> (fmap not . fmap even) [1,2]
[True,False]
#+end_example

#+begin_src haskell :results output
  :{
  data Tree a = Leaf a | Node (Tree a) (Tree a)
                deriving Show
  :}

  :{
  instance Functor Tree where
    fmap g (Leaf x)   = (Leaf (g x))
    fmap g (Node l r) = (Node (fmap g l) (fmap g r))
  :}

  fmap (1+) (Node (Leaf 1) (Leaf 2))
  fmap length (Node (Leaf "abcd") (Leaf "xyz"))

#+end_src

#+RESULTS:
: Node (Leaf 2) (Leaf 3)
: Node (Leaf 4) (Leaf 3)

#+begin_example
instance Functor IO where
  -- fmap :: (a -> b) -> IO a -> IO b
  fmap g mx = do {x <- mx; return (g x)}
#+end_example
First, the IO operation is done and its result is stored in =x=. Then =g= is applied to =x= and the result is wrapped with the type =IO= with =return=

#+begin_example
fmap show (return True)
#+end_example
=fmap= is applied to =show=, then =True= is wrapped inside a =IO= (?).

#+begin_src haskell :results output
  fmap show (Just 3)
  show (Just 3)
#+end_src

#+RESULTS:
: Just "3"
: Just 3

#+begin_example
ghci> fmap show (Just 3)
Just "3"
ghci> show (Just 3)
"Just 3"
#+end_example

#+begin_example
getStr :: String -> IO String
getStr x = do {y <- getChar; if y == '\n' then (return x) else (getStr (x ++ [y]))}
#+end_example

#+RESULTS:
: Cons 3 (Cons 2 Nil)
: Cons 2 (Cons 1 Nil)
: Cons False (Cons True Nil)
: Cons True (Cons False Nil)

** Applicative Functors
Applicatives generalize functors to functions with any number of arguments.
#+begin_src haskell :eval never
class Functor f => Applicative f where
   pure :: a -> f a
   (<*>) :: f (a -> b) -> f a -> f b
#+end_src

#+begin_example
pure (+1) <*> Just 1
Just (+1) <*> Just 1
fmap (+1) Just 1
Just ((+1) 1)
Just 2
#+end_example

#+begin_example
pure (+) <*> Just 1 <*> Just 2
Just (+) <*> Just 1 <*> Just 2
fmap (+) (Just 1) <*> Just 2
Just (1+) <*> Just 2
fmap (1+) (Just 2)
Just (1+2)
Just 3
#+end_example

#+begin_example
pure (+) <*> Nothing <*> Just 2
Just (+) <*> Nothing <*> Just 2
fmap (+) Nothing <*> Just 2
Nothing <*> Just 2
Nothing
#+end_example

=[a]= can be viewed as a generalization of =Maybe a= that permits multiple results in the case of success. The empty list is a failure and a non-empty list is the list of all possible ways in which a result may succeed.

#+begin_example
(*) <$> [1,2] <*> [3,4]
[(*)] <*> [1,2] <*> [3,4]
[(1*),(2*)] <*> [3,4]
[(1*3),(1*4),(2*)] <*> [3,4]
[(1*3),(1*4),(2*3),(2*4)]
[3,4,6,8]
#+end_example

Applicative functors allows us to write programs in a familiar style that may also have /effects./ The arguments of the application can also fail, succed in more than one way, do IO.

#+begin_src haskell :eval never
sequenceA :: Applicative f => [f a] -> f [a]
sequenceA []     = pure []
sequenceA (x:xs) = pure (:) <*> x <*> sequenceA xs
#+end_src

#+begin_src haskell :eval never
getChars :: Int -> IO String
getChars n = sequenceA (replicate n getChar)
#+end_src

Laws
#+begin_example
pure id <*> x   = x
pure (g x)      = pure g <*> pure x
x <*> pure y    = pure (\g -> g y) <*> x
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z
#+end_example
1. =pure= preserves the identity function
2. =pure= preserves function application
3. When an effectful function is applied to an pure argument, the order in which we evaluate the two components doesn't matter
4. Modulo the types involved, =<*>= associative.

#+begin_example
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z
#+end_example

#+begin_example
pure id <*> x = x

pure :: a -> f a
id :: a -> a
<*> :: f (a -> b) -> f a -> f b
x :: f a

pure id :: f (a -> a)
pure id <*> :: f a -> f b
pure id <*> x :: f b
#+end_example

#+begin_example
pure (g x) = pure g <*> pure x

pure :: a -> f a
g :: a -> b
x :: a
<*> :: f (a -> b) -> f a -> f b

pure g :: f (a -> b)
pure x :: f a
pure g <*> :: f a -> f b
pure g <*> pure x :: f b

g x :: b
pure (g x) :: f b
#+end_example

#+begin_example
x <*> pure y = pure (\g -> g y) <*> x

x :: f (a -> b)
<*> :: f (a -> b) -> f a -> f b
pure :: a -> f a
y :: a

x <*> :: f a -> f b
pure y :: f a
x <*> pure y :: f b

(\g -> g y) :: ((c -> b) -> b)
pure (\g -> g y) :: f ((c -> b) -> b)
pure (\g -> g y) <*> :: f (c -> b) -> f b
pure (\g -> g y) <*> x :: f b
x :: f (c -> b)
a :: c -> b
#+end_example

** Monads
#+begin_src haskell :results output
class Applicative m => Monad m where
   return :: a -> m a
   (>>=) :: m a -> (a -> m b) -> m b
   return = pure
#+end_src

Laws
#+begin_example
return x >>= f   = f x
mx >>= return    = mx
(mx >>= f) >>= g = mx >>= (\x -> (f x >>= g))
#+end_example

#+begin_src haskell :results output :compile yes
  type State = Int

  newtype ST a = S (State -> (a,State))

  app :: ST a -> State -> (a,State)
  app (S st) x = st x

  instance Functor ST where
    fmap g st = S (\s -> let (x,s') = app st s in (g x, s'))

  instance Applicative ST where
    pure x = S (\s -> (x,s))
    stf <*> stx = S (\s ->
      let (f,s')  = app stf s
          (x,s'') = app stx s' in (f x, s''))

  instance Monad ST where
    st >>= f = S (\s -> let (x,s') = app st s in app (f x) s')

  data Tree a = Leaf a | Node (Tree a) (Tree a)
                deriving Show

  tree :: Tree Char
  tree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')

  rlabel :: Tree a -> Int -> (Tree Int, Int)
  rlabel (Leaf _)   n = (Leaf n, n+1)
  rlabel (Node l r) n = (Node l' r', n'')
    where
      (l',n')  = rlabel l n
      (r',n'') = rlabel r n'


  fresh :: ST Int
  fresh = S (\n -> (n,n+1))

  alabel :: Tree a -> ST (Tree Int)
  alabel (Leaf _)   = Leaf <$> fresh
  alabel (Node l r) = Node <$> alabel l <*> alabel r

  mlabel :: Tree a -> ST (Tree Int)
  mlabel (Leaf _)   = do n <- fresh
                         return (Leaf n)
  mlabel (Node l r) = do l' <- mlabel l
                         r' <- mlabel r
                         return (Node l' r')


  main = do putStr "rlabel: "
            putStrLn (show (rlabel tree 0))
            putStr "alabel: "
            putStrLn (show (app (alabel tree) 0))
            putStr "mlabel: "
            putStrLn (show (app (mlabel tree) 0))
#+end_src

#+RESULTS:
: rlabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)
: alabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)
: mlabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)

#+begin_example
(rlabel tree 0)

(Node l' r', n'')
(l',n')  = rlabel (Node (Leaf 'a') (Leaf 'b')) 0
(r',n'') = rlabel (Leaf 'c') n'

(Node l' r', n'')
(l',n')  = rlabel (Leaf 'a') 0
(r',n'') = rlabel (Leaf 'b') n'

(Leaf 'a') 0 = (Leaf 0, 1)

(Node l' r', n'')
(Leaf 0,1)     = rlabel (Leaf 'a') 0
(r'    ,n'')   = rlabel (Leaf 'b') 1

(Leaf 'b') 1 = (Leaf 1, 2)

(Node l' r', n'')
(Leaf 0,1) = rlabel (Leaf 'a') 0
(Leaf 1,2) = rlabel (Leaf 'b') 1
((Node (Leaf 0) (Leaf 1)),2)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
(r',n'') = rlabel (Leaf 'c') 2

(Leaf 'c') 2 = ((Leaf 2),3)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
(r',n'') = rlabel (Leaf 'c') 2

(Leaf 'c') 2 = ((Leaf 2), 3)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
((Leaf 2),3)                  = ((Leaf 2), 3)

(Node (Node (Leaf 0) (Leaf 1)) (Leaf 2), 3)
#+end_example

#+begin_example
(app (alabel tree) 0)

(alabel Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c'))

Node <$> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')
pure Node <*> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')
S (\s -> (Node,s)) <*> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')

Node <$> alabel (Leaf 'a') <*> alabel (Leaf 'b')
S (\p -> (Node,p) <*> alabel (Leaf 'a') <*> alabel (Leaf 'b'))

alabel (Leaf 'a')
Leaf <$> fresh
S (\q -> (Leaf,q)) <*> fresh
S (\q -> (Leaf,q)) <*> S (\n -> (n, n+1))
S (\a ->
    let (f,a')  = app S (\q -> (Leaf,q)) a
    let (x,a'') = app fresh              a'
      in (f x,a''))
app S (\q -> (Leaf,q)) a = (Leaf,a)
app S (\n -> (n,n+1))  a = (a,a+1)
S (\a -> (Leaf a,a+1))

S (\p -> (Node,p)) <*> S (\a -> (Leaf a,a+1))
S (\a ->
    let (f,a')  = app S (\p -> (Node,p)) a
    let (x,a'') = app S (\b -> (Leaf b,b+1)) a'
      in (f x,a''))
app S (\p -> (Node,p)) a = (Node,a)
app S (\b -> (Leaf b,b+1))) a = (Leaf a,a+1)
S (\a -> ((Node (Leaf a)),a+1))

S (\a -> ((Node (Leaf a)),a+1)) <*> S (\a -> (Leaf a,a+1))
S (\c ->
    let (f,c')  = app S (\a -> ((Node (Leaf a)),a+1)) c
    let (x,c'') = app S (\a -> (Leaf a,a+1))          c'
      in (f x,c''))
app S (\a -> ((Node (Leaf a)),a+1)) c = ((Node (Leaf c)),c+1)
app S (\a -> (Leaf a,a+1)) (c+1) = (Leaf c+1,c+1+1)
S (\c -> ((Node (Leaf c)) (Leaf c+1),c+2))
S (\c -> (Node (Leaf c) (Leaf c+1),c+2))

S (\c -> (Node (Leaf c) (Leaf c+1),c+2)) <*> S (\a -> (Leaf a,a+1))
S (\s -> ((Node (Node (Leaf s) (Leaf s+1)) (Leaf s+2)),s+3))
#+end_example
** exercises
*** 1
#+begin_src haskell :results output
  :{
  data Tree a = Leaf | Node (Tree a) a (Tree a)
                deriving Show
  :}

  :{
  instance Functor Tree where
    -- fmap :: (a -> b) -> Tree a -> Tree b
    fmap _ Leaf         = Leaf
    fmap f (Node l m r) = Node (fmap f l) (f m) (fmap f r)
  :}

  fmap (2^) (Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf))
#+end_src

#+RESULTS:
: Node (Node Leaf 2 Leaf) 4 (Node Leaf 8 Leaf)
*** 2
#+begin_src haskell :results output
  :{
  instance Functor ((->) a) where
    -- fmap :: (a -> b) -> ((->) a) -> ((->) b)
    fmap = 
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-25: error:
:     Duplicate instance declarations:
:       instance Functor ((->) a) -- Defined at <interactive>:4:10
:       instance Functor ((->) r) -- Defined in ‘GHC.Base’
*** 4
#+begin_src haskell :results output
  newtype ZipList a = Z [a] deriving Show

  :{
  instance Functor ZipList where
    -- fmap :: (a -> b) -> ZipList a -> ZipList b
    fmap g (Z xs) = (Z (map g xs)) : (fmap g (Z xs))
  :}

  -- :{
  -- instance Applicative ZipList where
    -- pure :: a -> ZipList a
    -- pure x = Z x

    -- <*> :: ZipList (a -> b) -> ZipList a -> ZipList b
    -- (Z gs) <*> (Z xs) = 
  -- :}
#+end_src

#+RESULTS:
#+begin_example
<interactive>:8:19-50: error:
    • Couldn't match expected type: ZipList b
                  with actual type: [ZipList b]
    • In the expression: (Z (map g xs)) : (fmap g (Z xs))
      In an equation for ‘fmap’:
          fmap g (Z xs) = (Z (map g xs)) : (fmap g (Z xs))
      In the instance declaration for ‘Functor ZipList’
    • Relevant bindings include
        g :: a -> b (bound at <interactive>:8:8)
        fmap :: (a -> b) -> ZipList a -> ZipList b
          (bound at <interactive>:8:3)

<interactive>:8:45-48: error:
    • Couldn't match type ‘ZipList’ with ‘[]’
      Expected: [a]
        Actual: ZipList a
    • In the second argument of ‘fmap’, namely ‘(Z xs)’
      In the second argument of ‘(:)’, namely ‘(fmap g (Z xs))’
      In the expression: (Z (map g xs)) : (fmap g (Z xs))
#+end_example
* chapter 13
A Parser is a program that takes a input string and returns a tree that make syntactic structure of the string explicit. Making the structure explicit simplifies further processing.

A type for parsers can be:
#+begin_src haskell :eval never
type Parser a = String -> [(a,String)]
#+end_src
It takes a type argument since different information can be represented by different types. It returns a list with a pair consisting of the processed data and the remaining characters of the input string. The list represent the possibility of failure or multiple results. Note that this type is similar to the type of state transformers. A parser can be viewed as a generalised form of state transformer.
#+begin_src haskell :eval never
State -> (a,State)
#+end_src

#+name: monadic-parser-init
#+begin_src haskell :results output
  import Control.Applicative
  import Data.Char

  newtype Parser a = P (String -> [(a,String)])

  :{
  parse :: Parser a -> String -> [(a,String)]
  parse (P p) inp = p inp
  :}

  :{
  item :: Parser Char
  item = P (\inp -> case inp of
                       []     -> []
                       (x:xs) -> [(x,xs)])
  :}

  :{
  instance Functor Parser where
    -- fmap :: (a -> b) -> Parser a -> Parser b
    fmap g p = P (\inp -> case parse p inp of
                             []       -> []
                             [(x,xs)] -> [(g x, xs)])
  :}

  :{
  instance Applicative Parser where
    -- pure :: a -> Parser a
    pure x = P (\inp -> [(x,inp)])

    -- <*> :: Parser (a -> b) -> Parser a -> Parser b
    x <*> y = P (\inp -> case parse x inp of
                           []       -> []
                           [(g,gs)] -> parse (fmap g y) gs)
  :}
    
  :{
  three :: Parser (Char,Char)
  three = pure g <*> item <*> item <*> item
          where g x y z = (x,z)
  :}

  :{
  instance Monad Parser where
    -- (>>=) :: Parser a -> (a -> Parser b) -> Parser b
    p >>= f = P (\inp -> case parse p inp of
                           [] -> []
                           [(x,xs)] -> parse (f x) xs)
  :}


  -- i tried the following, but it doesn't work because
  -- then the right side of the equality would be of type
  -- Parser (Parser b). note that the type 'Parser b'
  -- refers to the whole right side of the equation, that's
  -- what tripped me.
  -- :{
  -- instance Monad Parser where
  --   -- (>>=) :: Parser a -> (a -> Parser b) -> Parser b
  --   p >>= f = P (\inp -> case parse p inp of
  --                          [] -> []
  --                          [(x,xs)] -> f x)
  -- :}

  -- shown in another way:
  -- P (\inp -> case parse p inp of
  --              [] -> []
  --              [(x,xs)] -> f x) :: Parser (Parser b)

  -- P (\inp -> case parse p inp of
  --              [] -> []
  --              [(x,xs)] -> parse (f x) xs) :: Parser b

  -- f x :: Parser b

  :{
  instance Alternative Parser where
    -- empty :: Parser a
    empty = P (\inp -> [])

    -- (<|>) :: Parser a -> Parser a -> Parser a
    p <|> q = P (\inp -> case parse p inp of
                           [] -> parse q inp
                           x  -> x)
  :}

  -- at first I thought:
  -- p <|> q = P (\inp -> case parse p inp of
  --                        [] -> q
  --                        x  -> x)

#+end_src

#+RESULTS: monadic-parser-init


#+begin_src haskell :results output :noweb yes
  <<monadic-parser-init>>

  parse item ""
  parse item "abc"

  parse (fmap (\x -> 1) item) "abc"
  parse (fmap (\x -> 1) item) ""

  parse (pure 1) "abc"

  parse three "abcdef"
  parse three "ab"
  parse three "xyz"

  parse empty "abc"

  parse (empty <|> return 'd') "abc"
#+end_src

#+RESULTS:
#+begin_example
[]
[('a',"bc")]
[(1,"bc")]
[]
[(1,"abc")]
[(('a','c'),"def")]
[]
[(('x','z'),"")]
[]
[('d',"abc")]
#+end_example

Alternative class.
#+begin_src haskell :eval never
  class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
#+end_src
=empty= represents an alternative that has failed. =<|>= is the chice operator.

Laws:
#+begin_example
empty <|> x   = x
x <|> empty   = x
x <|> y <|> z = (x <|> y) <|> z
#+end_example

#+name: monadic-parser-primitives
#+begin_src haskell :results output :noweb yes
  <<monadic-parser-init>>

  :{
  sat :: (Char -> Bool) -> Parser Char
  sat p = P (\inp -> case parse item inp of
                [] -> []
                [(x,xs)] -> if p x then [(x,xs)] else [])
  :}
  -- sat p = do x <- item
  --            if p x then return x else empty

  :{
  digit :: Parser Char
  digit = sat isDigit
  :}

  :{
  lower :: Parser Char
  lower = sat isLower
  :}

  :{
  upper :: Parser Char
  upper = sat isUpper
  :}

  :{
  letter :: Parser Char
  letter = sat isAlpha
  :}

  :{
  alphanum :: Parser Char
  alphanum = sat isAlphaNum
  :}

  :{
  char :: Char -> Parser Char
  char x = sat (== x)
  :}

  :{
  string :: String -> Parser String
  string []     = return []
  string (x:xs) = char x    >>= \y ->
                  string xs >>= \ys ->
                  P (\inp ->  [((y:ys),inp)])
  :}
  -- string (x:xs) = do char x
  --                    string xs
  --                    return (x:xs)

  :{
  ident :: Parser String
  ident = do x <- lower
             xs <- many alphanum
             return (x:xs)
  :}

  :{
  nat :: Parser Int
  nat = do xs <- some digit
           return (read xs)
  :}

  :{
  space :: Parser ()
  space = do many (sat isSpace)
             return ()
  :}

  :{
  int :: Parser Int
  int = do char '-'
           n <- nat
           return (-n)
         <|> nat
  :}

  :{
  token :: Parser a -> Parser a
  -- token p = do space
  --              v <- p
  --              space
  --              return v
  token p = space >>= \_ ->
            p >>= \v ->
            space >>= \_ ->
            return v
  :}

  :{
  identifier :: Parser String
  identifier = token ident
  :}

  :{
  natural :: Parser Int
  natural = token nat
  :}

  :{
  integer :: Parser Int
  integer = token int
  :}

  :{
  symbol :: String -> Parser String
  symbol xs = token (string xs)
  :}

  :{
  nats :: Parser [Int]
  nats = do symbol "["
            n <- natural
            ns <- many (do symbol ","
                           natural)
            symbol "]"
            return (n:ns)
  :}
#+end_src

#+RESULTS: monadic-parser-primitives

#+begin_src haskell :results output :noweb yes
  <<monadic-parser-primitives>>

  parse (sat (\c -> c == 'x')) "xbc"

  parse (char 'a') "abc"

  parse (string "abc") "abcdef"
  parse (string "abc") "xyzabcdef"

  parse ident "abc def"

  parse nat "123 abc"

  parse space "   abc"

  parse int "-123 abc"

  parse space "abc"

  parse (token (string "var")) "   var  xyz"

  parse nats "[1,2,3] xyz"
#+end_src

#+RESULTS:
#+begin_example
[('x',"bc")]
[('a',"bc")]
[("abc","def")]
[]
[("abc"," def")]
[(123," abc")]
[((),"abc")]
[(-123," abc")]
[((),"abc")]
[("var","xyz")]
[([1,2,3],"xyz")]
#+end_example

#+name: monadic-parser-arithmetic
#+begin_src haskell :results output :noweb yes
  <<monadic-parser-primitives>>

  :{
  expr :: Parser Int
  expr = do t <- term
            do symbol "+"
               e <- expr
               return (t + e)
             <|> return t

  term :: Parser Int
  term = do f <- factor
            do symbol "*"
               t <- term
               return (f * t)
             <|> return f

  factor :: Parser Int
  factor = do symbol "("
              e <- expr
              symbol ")"
              return e
            <|> natural
  :}

  :{
  eval :: String -> Int
  eval xs = case (parse expr xs) of
              [(n,[])]  -> n
              [(_,out)] -> error ("Unused input " ++ out)
              []        -> error "Invalid input"
  :}
#+end_src

#+RESULTS:

#+begin_src haskell :results output :noweb yes
  <<monadic-parser-arithmetic>>

  eval "2*3+4"
  eval "4+2*3"
  eval "2*(3+4)"
  eval "7"
  eval "7!"

#+end_src

#+RESULTS:
: 10
: 10
: 14
: 7
: *** Exception: Unused input !
: CallStack (from HasCallStack):
:   error, called at <interactive>:241:26 in interactive:Ghci28

#+begin_src haskell :results output :noweb yes
  <<monadic-parser-arithmetic>>

  eval "one plus two"
#+end_src

#+RESULTS:
: *** Exception: Invalid input
: CallStack (from HasCallStack):
:   error, called at <interactive>:242:26 in interactive:Ghci28

#+name: screen-utilities
#+begin_src haskell :results output
  import System.IO

  :{
  type Pos = (Int,Int)

  cls :: IO ()
  cls = putStr "\ESC[2J"

  writeat :: Pos -> String -> IO ()
  writeat p xs = do goto p
                    putStr xs

  goto :: Pos -> IO ()
  goto (x,y) = putStr ("\ESC[" ++ show y ++ ";" ++ show x ++ "H")


  getCh :: IO Char
  getCh = do hSetEcho stdin False
             x <- getChar
             hSetEcho stdin True
             return x
  :}
#+end_src

#+RESULTS: screen-utilities

#+begin_src haskell :eval never :noweb yes :tangle calculator.hs 

  <<screen-utilities>>

  <<monadic-parser-arithmetic>>

  :{
  box :: [String]
  box = ["+---------------+",
         "|               |",
         "+---+---+---+---+",
         "| q | c | d | = |",
         "+---+---+---+---+",
         "| 1 | 2 | 3 | + |",
         "+---+---+---+---+",
         "| 4 | 5 | 6 | - |",
         "+---+---+---+---+",
         "| 7 | 8 | 9 | * |",
         "+---+---+---+---+",
         "| 0 | ( | ) | / |",
         "+---+---+---+---+"]
  :}

  :{
  buttons :: String
  buttons = standard ++ extra
            where
              standard = "qcd=123+456-789*0()/"
              extra    = "QCD \ESC\BS\DEL\n"
  :}

  :{
  showbox :: IO ()
  showbox = sequence_ [writeat (1,y) b | (y,b) <- zip [1..] box]
  :}

  :{
  display :: String -> IO ()
  display xs = do writeat (3,2) (replicate 13 ' ')
                  writeat (3,2) (reverse (take 13 (reverse xs)))
  :}

  :{
  calc :: String -> IO ()
  calc xs = do display xs
               c <- getCh
               if elem c buttons then
                 process c xs
               else
                 do beep
                    calc xs

  beep :: IO ()
  beep = putStr "\BEL"

  process :: Char -> String -> IO ()
  process c xs | elem c "qQ\ESC"    = quit
               | elem c "dD\BS\DEL" = delete xs
               | elem c "=\n"       = eval xs
               | elem c "cC"        = clear
               | otherwise          = press c xs

  quit :: IO ()
  quit = goto (1,14)

  delete :: String -> IO ()
  delete [] = calc []
  delete xs = calc (init xs)

  eval :: String -> IO ()
  eval xs = case parse expr xs of
               [(n,[])] -> calc (show n)
               _        -> do beep
                              calc xs

  clear :: IO ()
  clear = calc []

  press :: Char -> String -> IO ()
  press c xs = calc (xs ++ [c])

  run :: IO ()
  run = do cls
           showbox
           clear
  :}

  run
#+end_src

To run the calculator, put the point on the block above, tangle with the key chord =C-u C-c C-v t= or =C-u M-x org-babel-tangle RET=, then run the script with:
#+begin_src bash :eval never
ghci -ghci-script calculator.hs
#+end_src

** 1
#+begin_src haskell :results output :noweb yes
  <<monadic-parser-primitives>>


  :{
  comment :: Parser ()
  comment = do string "--"
               many (sat (\c -> c /= '\n'))
               sat (\c -> c == '\n')
               return ()
  :}

  parse comment "-- abcde\n"
  parse comment "xyz --"
  parse comment "-- abcde"
  parse comment "-- this is a comment\nthis should remain"
  parse comment "--\n"
  parse comment "--"
#+end_src

#+RESULTS:
: [((),"")]
: []
: []
: [((),"this should remain")]
: [((),"")]
: []

** 2
#+begin_example
expr   ::= expr + expr | term
term   ::= term * term | factor
factor ::= ( expr ) | nat
nat    ::= 0 | 1 | 2
#+end_example

#+begin_example
                  expr
                /-  | ---
            /---    |    \---
          --        +        \-
         expr               term
          |                   |
         /|\                  |
        / | \              factor
       /  |  \                |
      /   +   \               |
    term     term            nat
     |         |              |
     |         |              |
  factor     factor           4
     |         |
     |         |
    nat       nat
     |         |
     |         |
     2         3
#+end_example

#+begin_example
           expr
         /-  | ---
     /---    |    \---
   --        +        \-
 term                expr
   |                  |
   |                 /|\
factor              / | \
   |               /  |  \
   |              /   +   \
  nat           term     term
   |             |         |
   |             |         |
   2          factor     factor
                 |         |
                 |         |
                nat       nat
                 |         |
                 |         |
                 3         4
#+end_example

** 3
#+begin_example
expr ::= term + expr | term
term ::= factor * term | factor
#+end_example

#+begin_example
         expr
         /|\
       -/ | \-
     -/   |   \
    /     +    \
  term        term
   |           |
   |           |
   |           |
factor       factor
   |           |
   |           |
   |           |
  nat         nat
   |           |
   |           |
   |           |
   2           3
#+end_example

#+begin_example
      expr
       |
       |
       |
      term
       |
      /|\
     / | \
    /  |  \
   /   *   \
factor    term
  |         |
  |        /|\
  |       / | \
 nat     /  |  \
  |     /   *   \
  |  factor   factor
  |    |         |
  2    |         |
       |         |
      nat       nat
       |         |
       |         |
       |         |
       3         4
#+end_example

#+begin_example
            expr
             |
            /|\
           / | \
          /  +  \
        term    4
         |       
         |       
      factor     
        |        
       /|\       
      / | \      
     /  |  \     
    (   |  )     
        |        
      expr       
       |         
      /|\        
     / | \       
    /  |  \      
   /   +   \     
 term     term   
  |         |    
  |         |    
factor    factor 
  |         |    
  |         |    
 nat       nat   
#+end_example

** 4
The final simplification saves information that would be lost otherwise, the whole string would be reprocessed.
* chapter 14
** Monoids
In Mathematics, a monoid is a set together with an associative operator that combines two elements from the set, and an identity element for the operator. For example, the set of integers forms a monoid with the operator given by addition and the identity element by the value zero. In Haskell, the notion of a monoid is captured by the following built-in class declaration:
#+begin_src haskell :eval never
class Monoid a where
  mempty :: a
  mappend :: a -> a -> a
  mconcat :: [a] -> a
  mconcat = foldr mappend mempty
#+end_src
The two primitives in the Monoid class are required to satisfy the following identity and associativity laws:
#+begin_src haskell :eval never
mempty `mappend` x = x
x `mappend` mempty = x
x `mappend` (y `mappend` z) = (x `mappend` y) `mappend` z
#+end_src
A particular type may give rise to a monoid in a number of different ways. For example, the integers form a monoid under addition and under multiplication. However, multiple instance declarations of the same type are not allowed in Haskell. To circumvent this, wrapper types can be created:
#+begin_src haskell :eval never
newtype Sum a = Sum a
  deriving (Eq, Ord, Show, Read)

getSum :: Sum a -> a
getSum (Sum x) = x

instance Num a => Monoid (Sum a) where
  -- mempty :: Sum a
  mempty = Sum 0
  -- mappend :: Sum a -> Sum a -> Sum a
  Sum x `mappend` Sum y = Sum (x+y)
#+end_src
#+begin_src haskell :eval never
newtype Product a = Product a
  deriving (Eq, Ord, Show, Read)

getProduct :: Product a -> a
getProduct (Product x) = x

instance Num a => Monoid (Product a) where
  -- mempty :: Product a
  mempty = Product 1
  -- mappend :: Product a -> Product a -> Product a
  Product x `mappend` Product y = Product (x*y)
#+end_src
** Foldables
Foldables are types that wrap Monoids. In other words, Foldables wrap around values that can be combined into one value.
#+begin_src haskell :eval never
class Foldable t where
  fold :: Monoid a => t a -> a
  foldMap :: Monoid b => (a -> b) -> t a -> b
  foldr :: (a -> b -> b) -> b -> t a -> b
  foldl :: (a -> b -> a) -> a -> t b -> a
#+end_src
foldr combines values from the right to the left, and foldl combines values from the left to the right. For example:
#+begin_example
foldr (+) 0 [1,2,3] = 1+(2+(3+0))
foldl (+) 0 [1,2,3] = (1+2)+3
#+end_example
The class also includes other useful functions:
#+begin_src haskell :eval never
null    :: t a -> Bool
length  :: t a -> Int
elem    :: Eq a => a -> t a -> Bool
maximum :: Ord a => t a -> a
minimum :: Ord a => t a -> a
sum     :: Num a => t a -> a
product :: Num a => t a -> a
foldr1 :: (a -> a -> a) -> t a -> a
foldl1 :: (a -> a -> a) -> t a -> a
toList :: t a -> [a]
#+end_src
The function toList plays a special role in the declaration of Foldable, it can be used to provide default definitions for most other primitives:
#+begin_src haskell :eval never
foldr f v = foldr f v . toList
foldl f v = foldl f v . toList
foldr1 f  = foldr1 f . toList
foldl1 f  = foldl1 f . toList
null      = null . toList
length    = length . toList
elem x    = elem x . toList
maximum   = maximum . toList
minimum   = minimum . toList
sum       = sum . toList
product   = product . toList
#+end_src
The following default definitions establish important relationships between primitives of the class:
#+begin_src haskell :eval never
fold = foldMap id
foldMap f = foldr (mappend . f) mempty
toList = foldMap (\x -> [x])
#+end_src
An important beneﬁt of abstracting out the concept of foldable types is the ability to use the primitives in the Foldable class to deﬁne generic functions that can be used with any such type:
#+begin_src haskell :eval never
average :: Foldable t => t Int -> Int
average ns = sum ns ‘div‘ length ns

and :: Foldable t => t Bool -> Bool
and = getAll . foldMap All

or :: Foldable t => t Bool -> Bool
or = getAny . foldMap Any

all :: Foldable t => (a -> Bool) -> t a -> Bool
all p = getAll . foldMap (All . p)

any :: Foldable t => (a -> Bool) -> t a -> Bool
any p = getAny . foldMap (Any . p)

concat :: Foldable t => t [a] -> [a]
concat = fold
#+end_src
** Traversables
The traversable class generalizes the concept of applying a function over a list.
#+begin_src haskell :eval never
class (Functor t, Foldable t) => Traversable t where
  traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
#+end_src
That is, for a parameterised type t that is both functorial and foldable to be an instance of the class Traversable, it must support a traverse function of the speciﬁed type. The requirement that t is a functor reﬂects the fact that traversables generalise the idea of mapping, and are hence expected to support the fmap primitive. The requirement that t is foldable ensures that values in a traversable type can also be folded up if desired.
Imagine that we have to map over a list, but the function may fail. We could write traverse as:
#+begin_src haskell :eval never
traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
traverse g []     = pure []
traverse g (x:xs) = pure (:) <*> g x <*> traverse g xs
#+end_src
The class generalizes this to other functors and foldables.
** Exercises
*** 1
#+begin_src haskell :eval never
instance (Monoid a, Monoid b) => Monoid (a,b) where
  -- mempty :: (a,b)
  mempty = (mempty, mempty)
  -- mappend :: (a,b) -> (a,b) -> (a,b)
  (x1,y1) `mappend` (x2,y2) = (x1 `mappend` x2,
                               y1 `mappend` y2)
#+end_src
*** 2
#+begin_src haskell :eval never
instance Monoid b => a -> b where
  -- mempty :: ?
  mempty = ?
  -- mappend :: (a -> b) -> (a -> b) -> (a -> b)
  f `mappend` g = ?
#+end_src
*** 3
#+begin_src haskell :eval never
instance Foldable Maybe where
  -- fold :: Monoid a => Maybe a -> a
  fold Nothing = mempty
  fold Just x  = x

  -- foldMap :: Monoid b => (a -> b) -> Maybe a -> b
  foldMap g Nothing  = mempty
  foldmap g (Just x) = g x

  -- foldr :: (a -> b -> b) -> b -> Maybe a -> b
  foldr g v Nothing  = v
  foldr g v (Just x) = g x v

  -- foldl :: (a -> b -> a) -> a -> Maybe b -> a
  foldl g v Nothing  = v
  foldl g v (Just x) = g v x
#+end_src
* chapter 15
#+begin_src haskell :results output
  :{
  primes = let someNats   = [2..]
               firstPrime = head someNats
               restNats   = tail someNats
           in
             firstPrime : (filter (\x -> x `rem` firstPrime /= 0) restNats)
  :}

  take 10 primes
#+end_src

#+RESULTS:
: [2,3,5,7,9,11,13,15,17,19]

Reducible expression or redex: an expression of the form of a function applied to one or more arguments that can be reduced. Reducing redexes does not necessarily decrease the size of the expression.

The function
#+begin_example
mult :: (Int,Int) -> Int
mult (x,y) = x + y
#+end_example
in the expression
#+begin_example
mult (1+2,2+3)
#+end_example
contains three redexes:
#+begin_example
1. 1+2
2. 2+3
3. mult (1+2,2+3)
#+end_example

Reducing redexes within lambda expressions is prohibited is Haskell. The only operation that can be performed on a function is applying it to an argument. Once the function =\x -> 1 + 2= has been applied to an argument, evaluation of the resulting redex can proceed.

Innermost redex: contains no other redex. Innermost evaluation: evaluation strategy that evaluates the innermost redexes first, choosing the leftmost redex if there is more than one innermost redex. This strategy ensures that arguments are always fully evaluated before functions are applied. In other words, arguments are passed *by value.*

Outermost redex: is contained by no other redex. Outermost evaluation: evaluates outermost redex first, left to right. Arguments are passed *by name.*

Strict functions: their arguments have to be applied before being passed to them.

Call-by-value: innermost evaluation of redexes not within lambda expressions. Will produce the smallest number of evaluation steps. Call-by-name: outermost evaluation of redexes not within lambda expressions. Will always terminate evaluation if there is at least one way to terminate it.

Sharing: a pointer to the result of evaluating an expression is used instead of the evaluation being repeated. It is important because with call-by-value evaluation arguments to functions can be repeated in their bodies, resulting in needless recomputation when not shared.

Lazy evaluation: call-by-name + sharing.

$! operator allows to apply functions strictly, ie evaluate function arguments before application. It can help manage space complexity.

** Exercises
*** 4
#+begin_src haskell :results output
  :{
  fibs :: [Integer]
  fibs = 0 : (1 : [x+y | (x,y) <- zip fibs (tail fibs)])
  :}
  take 55 fibs
#+end_src

#+RESULTS:
: [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,32951280099,53316291173,86267571272]
