# -*- org-confirm-babel-evaluate: nil; eval: (setq-local org-structure-template-alist (cons '("hs" . "src haskell :results output") org-structure-template-alist)) -*-
#+STARTUP: overview

book: Programming in Haskell - Graham Hutton

* chapter 1
** 3
#+begin_src haskell :compile yes
  module Main where

  myProduct [] = 1
  myProduct (x:xs) = x * (myProduct xs)

  main :: IO ()
  main =
    putStrLn (show (myProduct [2,3,4]))
#+end_src

#+RESULTS:
: 24

** 4
#+begin_src haskell :compile yes
  module Main where

  qsort []     = []
  qsort (x:xs) = qsort larger ++ [x] ++ qsort smaller
                 where
                   smaller = [a | a <- xs, a <= x]
                   larger  = [b | b <- xs, b > x]

  main :: IO ()
  main =
    putStrLn (show (qsort [2,2,3,1,1]))

#+end_src

#+RESULTS:
| [3 | 2 | 2 | 1 | 1] |
** 5
#+begin_src haskell :compile yes
  module Main where

  qsort []     = []
  qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger
                 where
                   smaller = [a | a <- xs, a < x]
                   larger  = [b | b <- xs, b > x]

  main :: IO ()
  main =
    putStrLn (show (qsort [2,2,3,1,1]))

#+end_src

#+RESULTS:
| [1 | 2 | 3] |

At first I thought it would remove only the duplicates of the first element of the list. But reading the output of the program, I realise that it will remove duplicates of the first element of each sublist processed.

#+begin_example
[2, 2, 3, 1, 1]

[1, 1] ++ [2] ++ [3]

([] ++ [1] ++ []) ++ [2] ++ [3]

[1] ++ [2] ++ [3]

[1, 2] ++ [3]

[1, 2, 3]
#+end_example

* chapter 2
** 3
#+begin_src haskell :compile yes :results output
  module Main where

  n = a `div` (length xs)
    where
      a  = 10
      xs = [1,2,3,4,5]

  main :: IO ()
  main =
    putStrLn (show n)
#+end_src

#+RESULTS:
: 2

* chapter 3
** 3
#+begin_src haskell :results none
  second :: [a] -> a
  swap :: (t1, t2) -> (t2, t1)
  pair x y :: t1 -> t2 -> (t1, t2)
  double x :: Num a => a -> a
  palindrome xs :: [a] -> Bool
  twice :: (t1 -> t2) -> t1 -> t2
#+end_src

** 4
#+begin_src haskell :results output
  second xs = head (tail xs)
  :type second
#+end_src

#+RESULTS:
: second :: [a] -> a

#+begin_src haskell :results output
  swap (x,y) = (y,x)
  :type swap
#+end_src

#+RESULTS:
: swap :: (b, a) -> (a, b)

#+begin_src haskell :results output
  pair x y = (x,y)
  :type pair
#+end_src

#+RESULTS:
: pair :: a -> b -> (a, b)

#+begin_src haskell :results output
  double x = x * 2
  :type double
#+end_src

#+RESULTS:
: double :: Num a => a -> a

#+begin_src haskell :results output
  palindrome xs = reverse xs == xs
  :type palindrome
#+end_src

#+RESULTS:
: palindrome :: Eq a => [a] -> Bool
❌
Forgot to take into account that elements of the list have to have a type that is instance of =Eq=.

#+begin_src haskell :results output
  twice f x = f (f x)
  :type twice
#+end_src

#+RESULTS:
: twice :: (t -> t) -> t -> t

❌
If =f= is going to be applied to =f x=, the type of the output of =f= necessarily has to be the same as the input.

** 5
Function types encode the types of the inputs and outputs. It would be wrong to say that a function that doubles numbers is the same as a function that squares numbers, even though they have the same types and quantity of inputs and outputs. It would also be wrong to say that a function that computes double of numbers by means of multiplication is different from a function that computes double of numbers by means of addition. It would be feasible if the type system could infer the exact elements of the inputs and the exact elements of the output of a function, not only their types.

* chapter 4
** 1
#+begin_src haskell :results output
  halve ns = let n = length ns `div` 2 in (take n ns, drop n ns)

  halve [1,2,3,4,5,6]

  halve [1,2,3]

  :type halve
#+end_src

#+RESULTS:
: ([1,2,3],[4,5,6])
: ([1],[2,3])
: halve :: [a] -> ([a], [a])
** 2
*** a
#+begin_src haskell :results output
  third ns = head (tail (tail ns))

  third [1,2,3]

  :type third
#+end_src

#+RESULTS:
: 3
: third :: [a] -> a

*** b
#+begin_src haskell :results output
  third ns = ns !! 2

  third [4,5,6]

  :type third
#+end_src

#+RESULTS:
: 6
: third :: [a] -> a

*** c
#+begin_src haskell :results output
  third (f:(s:(t:xs))) = t

  third [7,8,9]

  :type third
#+end_src

#+RESULTS:
: 9
: third :: [a] -> a
** 3
*** a
#+begin_src haskell :results output
  safetail ns = if null ns then ns else tail ns

  safetail []

  safetail [1]

  safetail [1,2]

  :type safetail
#+end_src

#+RESULTS:
: []
: []
: [2]
: safetail :: [a] -> [a]

*** b
#+begin_src haskell :results output
  :{
  safetail ns | null ns   = ns
              | otherwise = tail ns
  :}

  safetail []

  safetail [1]

  safetail [1,2]

  :type safetail    
#+end_src

#+RESULTS:
: []
: []
: [2]
: safetail :: [a] -> [a]

*** c
#+begin_src haskell :results output
  :{
  safetail []     = []
  safetail (x:xs) = xs
  :}

  safetail []

  safetail [7]

  safetail [7,8]

  :type safetail    
#+end_src

#+RESULTS:
: []
: []
: [8]
: safetail :: [a] -> [a]
** 4
#+begin_src haskell
  True  || True  = True
  False || True  = True
  True  || False = True
  False || False = False
#+end_src

#+begin_src haskell
  True || _    = True
  _    || True = True
  _    || _    = False
#+end_src

#+begin_src haskell
  False ||     b = b
  b     || False = b
#+end_src

#+begin_src haskell
  b || c | b == False = c
         | otherwise  = True
#+end_src

#+begin_src haskell :results output
  :{
  True  % True  = True
  False % True  = True
  True  % False = True
  False % False = False
  :}

  True % False
  False % False
#+end_src

#+RESULTS:
: True
: False
** 5
#+begin_src haskell :results output
  a % b = if a then b else if b then a else False

  True % True
  True % False
  False % True
  False % False
#+end_src

#+RESULTS:
: True
: False
: False
: False
** 6
#+begin_src haskell :results output
n  a % b = if a then b else False

  True % True
  True % False
  False % True
  False % False
#+end_src

#+RESULTS:
: True
: False
: False
: False
** 7
#+begin_src haskell :results output
  :{
  mult :: Int -> Int -> Int -> Int
  mult = \x -> (\y -> (\z -> x*y*z))
  :}

  mult 2 3 4
#+end_src

#+RESULTS:
: 24
** 8
#+begin_src haskell :results output
  :{
  decimalDigits n | n == 0    = 1
                  | otherwise = floor (1 + (logBase 10 (abs n)))
  :}

  decimalDigits 1234
  :type decimalDigits
#+end_src

#+RESULTS:
: 4
: decimalDigits
:   :: (RealFrac a1, Integral a2, Floating a1) => a1 -> a2

#+begin_src haskell :results output
  luhnDouble n = let twon = (2 * n) in if twon > 9 then twon - 9 else twon

  luhnDouble 3

  luhnDouble 6
#+end_src

#+RESULTS:
: 6
: 3

#+begin_src haskell :results output
  luhnDouble n = let twon = (2 * n) in if twon > 9 then twon - 9 else twon
    
  luhn a b c d = sum [luhnDouble a, b, luhnDouble c, d] `mod` 10 == 0

  luhn 1 7 8 4

  luhn 4 7 8 3

  :type luhn
#+end_src

#+RESULTS:
: True
: False
: luhn :: Integral a => a -> a -> a -> a -> Bool

* chapter 5
** 1
#+begin_src haskell :results output
  sum [x^2 | x <- [1..100]]
#+end_src

#+RESULTS:
: 338350
** 2
#+name: grid
#+begin_src haskell :results output
  :{
  grid :: Int -> Int -> [(Int, Int)]
  grid x y = [(x', y') | x' <- [0..x], y' <- [0..y]]
  :}

  grid 1 2
#+end_src

#+RESULTS:
: [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
** 3
#+begin_src haskell :results output :noweb yes
  <<grid>>
  square n = [(x, y) | (x, y) <- grid n n, x /= y]

  square 2
#+end_src

#+RESULTS:
: [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
: [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]
** 4
#+begin_src haskell :results output
  replicate n e = [e | _ <- [1..n]]

  replicate 3 True
#+end_src

#+RESULTS:
: [True,True,True]
** 5
#+begin_src haskell :results output
  :{
  pyths :: Int -> [(Int,Int,Int)]
  pyths n = [(x,y,z) | x <- xs, y <- xs, z <- xs, x^2 + y^2 == z^2]
             where xs = [1..n]
  :}

  pyths 10
#+end_src

#+RESULTS:
: [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
** 6
#+begin_src haskell :results output
  factors n = [x | x <- [1..n], n `mod` x == 0]

  perfect n = n == (sum (init (factors n)))

  perfects n = [x | x <- [1..n], perfect x]

  perfects 500
#+end_src

#+RESULTS:
: [6,28,496]
** 7
#+begin_src haskell :results output
  [(x,y) | x <- [1,2], y <- [3, 4]]
#+end_src

#+RESULTS:
: [(1,3),(1,4),(2,3),(2,4)]
?
** 8
#+begin_src haskell :results output
  find k t = [v | (k',v) <- t, k == k']

  -- positions x xs = [i | (x',i) <- zip xs [0..], x == 'x]

  positions x xs = find x (zip xs [0..])

  positions False [True, False, True, False]

#+end_src

#+RESULTS:
: [1,3]

** 9
#+begin_src haskell :results output
  scalarproduct xs ys = sum [x * y | (x, y) <- zip xs ys]

  scalarproduct [1,2,3] [4,5,6]
#+end_src

#+RESULTS:
: 32

* chapter 6
** 2
#+begin_src haskell :results output
  :{
  sumDown 0 = 0
  sumDown n = n + sumDown (n - 1)
  :}

  sumDown 3
#+end_src

#+RESULTS:
: 6
** 3
#+begin_src haskell :results output
  :{
  a % 1 = a
  a % b = a * (a % (b - 1))
  :}

  2 % 10
  2 % 3
#+end_src

#+RESULTS:
: 1024
: 8

#+begin_example
  2 % 3
=   { applying % }
  2 * ( 2 % 2 )
=   { applying % }
  2 * ( 2 * ( 2 % 1 ))
=   { applying % }
  2 * ( 2 * ( 2 ))
=   { applying * }
  2 * ( 4 )
=   { applying * }
  8
#+end_example
** 4
#+begin_src haskell :results output
  :{
  euclid a b | a == b    = a
             | a < b     = euclid a (b - a)
             | otherwise = euclid (a - b) b
  :}

  euclid 6 27
#+end_src

#+RESULTS:
: 3
** 6
*** a
#+begin_src haskell :results output
  :{
  and [x]    = x
  and (x:xs) = x && and xs
  :}

  and [True, True, True]
  and [True, True, False]
#+end_src

#+RESULTS:
: True
: False
*** b
#+begin_src haskell :results output
  :{
  concat []     = []
  concat (x:xs) = x ++ concat xs
  :}

  concat [[1,2],[3,4]]
#+end_src

#+RESULTS:
: [1,2,3,4]
*** c
#+begin_src haskell :results output
  :{
  replicate 0 a = []
  replicate n a = [a] ++ replicate (n - 1) a
  :}

  replicate 10 'a'
#+end_src

#+RESULTS:
: aaaaaaaaaa
*** e
#+begin_src haskell :results output
  :{
  elem e []     = False
  elem e (x:xs) = e == x || elem e xs
  :}

  elem 5 [1..10]
  elem 6 [1..5]
#+end_src

#+RESULTS:
: True
: False
** 7
#+begin_src haskell :results output
  :{
  merge []     []     = []
  merge []     (y:ys) = (y:ys)
  merge (x:xs) []     = (x:xs)
  merge (x:xs) (y:ys) | x <= y    = [x,y] ++ merge xs ys
                      | otherwise = [y,x] ++ merge xs ys
  :}

  merge [2,5,6] [1,3,4]
#+end_src

#+RESULTS:
: [1,2,3,5,4,6]
** 8
#+begin_src haskell :results output
  :{
  merge []     []     = []
  merge []     (y:ys) = (y:ys)
  merge (x:xs) []     = (x:xs)
  merge (x:xs) (y:ys) | x <= y    = [x] ++ merge xs (y:ys) -- !
                      | otherwise = [y] ++ merge (x:xs) ys -- !
  :}

  :{
  halve lst = (take l lst, drop l lst)
    where l = (length lst) `div` 2
  :}

  :{
  msort []  = []
  msort [x] = [x]
  msort lst = merge (msort a) (msort b)
    where
      (a,b) = halve lst
  :}

  merge [6] [3]
  msort (reverse [1..10])
#+end_src

#+RESULTS:
: [3,6]
: [1,2,3,4,5,6,7,8,9,10]

Had to look merge sort on Wikipedia.
** 9
*** c
#+begin_src haskell :results output
  -- 1
  -- last :: [a] -> a
  -- 2,3,4,5
  :{
  last [a]    = a
  last (a:ax) = last ax
  :}

  last [1..10]
#+end_src

#+RESULTS:
: 10

* chapter 7

** 1
#+begin_src haskell :results output
  mapFilter f p lst = [f x | x <- lst, p x]

  mapFilter' f p lst = map f (filter p lst)

  mapFilter (1+) odd [1..10] == mapFilter' (1+) odd [1..10]
#+end_src

#+RESULTS:
: True

** 2

*** d
#+begin_src haskell :results output
  :{
  myDropWhile p []  = []
  myDropWhile p (x:xs) | p x       = myDropWhile p xs
                       | otherwise = (x:xs)
  :}

  myDropWhile odd [1,3,5,7,8,9,10]
#+end_src

#+RESULTS:
: [8,9,10]

** 3
#+begin_src haskell :results output
  myMap f lst = foldr ((:) . f) [] lst
  myMap (2*) [1..10] == map (2*) [1..10]

  myFilter p lst = foldr (\y -> \z -> if p y then y:z else z) [] lst
  myFilter odd [1..10] == filter odd [1..10]
#+end_src

#+RESULTS:
: True
: True

** 4
#+begin_src haskell :results output
  dec2int lst = foldl (\y z -> y*10+z) 0 lst

  dec2int [2,3,4,5]
#+end_src

#+RESULTS:
: 2345

** 5
#+begin_src haskell :results output
  myCurry f = \x y -> f (x, y)
  myUncurry f = \(x, y) -> f x y

  myCurry (\(x, y) -> x + y) 1 2
  myUncurry (+) (1,2)
#+end_src

#+RESULTS:
: 3
: 3

** 9
#+begin_src haskell :results output
  :{
  altMap f g []     = []
  altMap f g (x:xs) = f x : altMap g f xs
  :}

  altMap (+10) (+100) [0,1,2,3,4]
#+end_src

#+RESULTS:
: [10,101,12,103,14]

* chapter 8

** 1
#+begin_src haskell :results output
  data Nat = Zero | Succ Nat

  :{
  nat2int :: Nat -> Int
  nat2int Zero     = 0
  nat2int (Succ n) = 1 + nat2int n
  :}

  :{
  int2nat :: Int -> Nat
  int2nat 0 = Zero
  int2nat n = Succ (int2nat (n-1))
  :}

  :{
  add :: Nat -> Nat -> Nat
  add Zero n = n
  add (Succ m) n = Succ (add m n)
  :}

  :{
  mult :: Nat -> Nat -> Nat
  mult Zero        _           = Zero
  mult _           Zero        = Zero
  mult (Succ Zero) n           = n
  mult m           (Succ Zero) = m
  mult (Succ m) n              = add n (mult m n)
  :}

  nat2int (mult (Succ (Succ Zero)) (Succ (Succ (Succ Zero))))

  nat2int (mult Zero (Succ (Succ (Succ Zero))))

  nat2int (mult (Succ Zero) (Succ (Succ (Succ Zero))))

  nat2int (mult (Succ (Succ (Succ Zero))) (Succ (Succ (Succ Zero))))
#+end_src

#+RESULTS:
: 6
: 0
: 3
: 9

** 2
#+begin_src haskell :results output
  data Tree a = Leaf a | Node (Tree a) a (Tree a)

  :{
  t :: Tree Int
  t = Node (Node (Leaf 1) 3 (Leaf 4)) 5
           (Node (Leaf 6) 7 (Leaf 9))
  :}

  :{   
  occurs :: Ord a => a -> Tree a -> Bool
  occurs x (Leaf y)                         = compare x y == EQ
  occurs x (Node l y r) | compare x y == EQ = True
                        | compare x y == LT = occurs x l
                        | otherwise         = occurs x r
  :}

  occurs 1 t
  occurs 11 t
#+end_src

#+RESULTS:
: True
: False

No idea.

** 3
#+name: balanced
#+begin_src haskell :results output
  data Tree a = Leaf a | Node (Tree a) (Tree a)

  :{
  numberOfLeaves :: Tree a -> Int
  numberOfLeaves (Leaf _)   = 1
  numberOfLeaves (Node l r) = numberOfLeaves l + numberOfLeaves r
  :}

  :{
  balanced :: Tree a -> Bool
  balanced (Leaf _)   = True
  balanced (Node l r) =  abs (subtract nl nr) <= 1
    where
      nl = numberOfLeaves l
      nr = numberOfLeaves r
  :}
#+end_src

#+RESULTS: balanced

#+begin_src haskell :results output :noweb yes
  <<balanced>>
  :{
  shouldBeBalanced :: Tree Int
  shouldBeBalanced = Node
    (Node (Leaf 1) (Leaf 2))
    (Node (Leaf 3) (Leaf 4))
  :}

  balanced shouldBeBalanced

  :{
  shouldNotBeBalanced :: Tree Int
  shouldNotBeBalanced = Node
    (Node (Leaf 1) (Node (Leaf 2) (Leaf 3)))
    (Leaf 4)
  :}

  balanced shouldNotBeBalanced
#+end_src

#+RESULTS:
: True
: False

** 4
#+begin_src haskell :results output :noweb yes
  <<balanced>>


  :{
  halve :: [a] -> ([a], [a])
  halve lst = (take n lst, drop n lst)
    where
      n = (length lst) `div` 2
  :}

  :{
  balance :: [a] -> Tree a
  balance [x] = Leaf x
  balance lst = Node (balance l) (balance r)
    where
      (l, r) = halve lst
  :}

  balanced $ balance [1,2,3,4,5]
  balanced $ balance [1,2,3,4]
#+end_src

#+RESULTS:
: True
: True

** 5
#+name: folde
#+begin_src haskell :results output
  data Expr = Val Int | Add Expr Expr

  :{
  folde :: (Int -> a) -> (a -> a -> a) -> Expr -> a
  folde f g (Val n) = f n
  folde f g (Add m n) = g (folde f g m)
                          (folde f g n)
  :}
#+end_src

** 6
#+begin_src haskell :results output :noweb yes
  <<folde>>

  :{
  eval :: Expr -> Int
  eval = folde id (+)
  :}

  :{
  size :: Expr -> Int
  size = folde (\x -> 1) (+)
  :}

  let exp = (Add (Val 1) (Add (Val 2) (Val 3)))

  size exp
  eval exp
#+end_src

#+RESULTS:
: 3
: 6

** 7
#+begin_src haskell :results output
  :{
  instance Eq a => Eq (Maybe a) where
    (Just x) == (Just y) = x == y
    _        == _        = False
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-29: error:
:     Duplicate instance declarations:
:       instance Eq a => Eq (Maybe a) -- Defined at <interactive>:4:10
:       instance Eq a => Eq (Maybe a) -- Defined in ‘GHC.Maybe’

#+begin_src haskell :results output
  :{
  instance Eq a => Eq [a] where
    [] == []         = True
    [] == _          = False
    _  == []         = False
    (x:xs) == (y:ys) = x == y && xs == ys
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-23: error:
:     Duplicate instance declarations:
:       instance Eq a => Eq [a] -- Defined at <interactive>:4:10
:       instance Eq a => Eq [a] -- Defined in ‘GHC.Classes’

** 8
#+begin_src haskell :results output
  eval s (Or p q)    = eval s p || eval s q
  eval s (Equiv p q) = eval s p == eval
#+end_src

* chapter 9
#+name: eval
#+begin_src haskell :results output
  data Op = Add | Sub | Mul | Div

  :{
  instance Show Op where
    show Add = "+"
    show Sub = "-"
    show Mul = "*"
    show Div = "/"
  :}

  :{
  valid :: Op -> Int -> Int -> Bool
  valid Add _ _ = True
  valid Sub x y = x > y
  valid Mul _ _ = True
  valid Div x y = x `mod` y == 0
  :}

  :{
  apply :: Op -> Int -> Int -> Int
  apply Add x y = x + y
  apply Sub x y = x - y
  apply Mul x y = x * y
  apply Div x y = x `div` y
  :}

  data Expr = Val Int | App Op Expr Expr

  :{
  instance Show Expr where
    show (Val n)     = show n
    show (App o l r) = brak l ++ show o ++ brak r
      where
        brak (Val n) = show n
        brak e       = "(" ++ show e ++ ")"
  :}

  show (App Add (Val 1) (App Mul (Val 2) (Val 3)))

  :{
  values :: Expr -> [Int]
  values (Val n) = [n]
  values (App _ l r) = values l ++ values r
  :}

  :{
  eval :: Expr -> [Int]
  eval (Val n) = [n | n > 0]
  eval (App o l r) = [apply o x y | x <- eval l,
                                    y <- eval r,
                                    valid o x y]
  :}

  eval (App Add (Val 2) (Val 3))
  eval (App Sub (Val 2) (Val 3))
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []

#+name: choices
#+begin_src haskell :results output
  :{
  subs :: [a] -> [[a]]
  subs []     = [[]]
  subs (x:xs) = yss ++ map (x:) yss
                where yss = subs xs
  :}

  :{
  interleave :: a -> [a] -> [[a]]
  interleave x [] = [[x]]
  interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)
  :}

  :{
  perms :: [a] -> [[a]]
  perms [] = [[]]
  perms (x:xs) = concat (map (interleave x) (perms xs))
  :}

  subs [1,2,3]

  :{
  choices :: [a] -> [[a]]
  choices = concat . map perms . subs
  :}
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]

#+begin_example
subs [1,2,3]
= (applying subs)
yss ++ map (1:) yss
where yss = subs [2,3]
= (applying subs [2,3])
yss ++ map (2:) yss
where yss = subs [3]
= (applying subs [3])
yss ++ map (3:) yss
where yss = subs []
= (applying subs [])
yss ++ map (3:) yss
where yss = [[]]
= (replacing yss for [[]])
[[]] ++ map (3:) [[]]
= (applying map)
[[]] ++ [[3]]
= (applying ++)
[[],[3]]
= (replacing yss for [[],[3]]
[[],[3]] ++ map (2:) [[],[3]]
= (applying map)
[[],[3]] ++ [[2],[2,3]]
= (applying ++)
[[],[3],[2],[2,3]]
= (replacing yss for [[],[3],[2],[2,3]])
[[],[3],[2],[2,3]] ++ map (1:) [[],[3],[2],[2,3]]
= (applying map)
[[],[3],[2],[2,3]] ++ [[1],[1,3],[1,2],[1,2,3]]
= (applying ++)
[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
#+end_example

#+begin_example
interleave 1 [2,3,4]
= (applying interleave)
(1:2:[3,4]) : map (2:) (interleave 1 [3,4])
= (applying interleave)
(1:3:[4]) : map (3:) (interleave 1 [4])
= (applying interleave)
(1:4:[]) : map (4:) (interleave 1 [])
= (applying interleave)
(1:4:[]) : map (4:) [[1]]
= (applying map)
(1:4:[]) : [[4,1]]
= (applying :)
[[1,4],[4,2]]
= (replacing (interleave 1 [4]) for [[1,4],[4,2]])
(1:3:[4]) : map (3:) [[1,4],[4,2]]
= (applying map)
(1:3:[4]) : [[3,1,4],[3,4,2]]
= (applying :)
[[1,3,4],[3,1,4],[3,4,2]]
= (replacing (interleave 1 [3,4]) for [[1,3,4],[3,1,4],[3,4,2]]
[1,2,3,4] : map (2:) [[1,3,4],[3,1,4],[3,4,2]]
= (applying map)
[1,2,3,4] : [[2,1,3,4],[2,3,1,4],[2,3,4,2]]
= (applying :)
[[1,2,3,4],[2,1,3,4],[2,3,1,4],[2,3,4,2]]
#+end_example

#+begin_example
perms [1,2,3]
= (applying perms)
perms (1:[2,3]) = concat (map (interleave 1) (perms [2,3]))
= (applying perms)
perms (2:[3]) = concat (map (interleave 2) (perms [3]))
= (applying perms)
perms (3:[]) = concat (map (interleave 3) (perms []))
= (applying perms)
perms (3:[]) = concat (map (interleave 3) [[]])
= (applying map)
perms (3:[]) = concat [[[3]]]
= (applying concat)
perms (3:[]) = [[3]]
= (replacing (perms [3]) for [[3]])
perms (2:[3]) = concat (map (interleave 2) [[3]])
= (applying map)
perms (2:[3]) = concat [[[2,3],[3,2]]]
= (applying concat)
perms (2:[3]) = [[2,3],[3,2]]
= (replacinng (perms [2,3]) for [[2,3],[3,2]])
perms (1:[2,3]) = concat (map (interleave 1) [[2,3],[3,2]])
= (applying map)
perms (1:[2,3]) = concat [[[1,2,3],[2,1,3],[2,3,1]],[[1,3,2],[3,1,2],[3,2,1]]]
= (applying concat)
perms (1:[2,3]) = [[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
#+end_example

#+begin_example
choices [1,2,3]
= (applying choices)
concat . map perms . subs [1,2,3]
= (applying subs)
concat . map perms [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
= (applying map)
concat . [[[]],[[3]],[[2]],[[2,3],[3,2]],[[1]],[[1,3],[3,1]],[[1,2],[2,1]],[[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]]
= (applying concat)
[[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]
#+end_example

#+name: solution
#+begin_src haskell :results output :noweb yes
  <<eval>>
  <<choices>>
  :{
  solution :: Expr -> [Int] -> Int -> Bool
  solution e ns n =
    elem (values e) (choices ns) && eval e == [n]
  :}

  solution (App Mul (App Add (Val 1) (Val 50)) (App Sub (Val 25) (Val 10))) [1,3,7,10,25,50] 765
#+end_src

#+RESULTS: solution
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

#+begin_src haskell :results output :noweb yes :tangle yes :comments noweb
  <<solution>> 
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True

Performance testing was done by tangling this file, then changing the generated file according to the book.

#+begin_src bash
  ghc -O2 countdown.hs > /dev/null
  (time (./countdown > /dev/null)) 2> countdown-time.txt
  cat countdown-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m7.600s |
| user | 0m7.579s |
| sys  | 0m0.020s |

#+begin_src bash
  ghc -O2 countdown-v2.hs > /dev/null
  (time (./countdown-v2 > /dev/null)) 2> countdown-v2-time.txt
  cat countdown-v2-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m0.483s |
| user | 0m0.462s |
| sys  | 0m0.020s |

#+begin_src bash
  ghc -O2 countdown-v3.hs > /dev/null
  (time (./countdown-v3 > /dev/null)) 2> countdown-v3-time.txt
  cat countdown-v3-time.txt
#+end_src

#+RESULTS:
|      |          |
| real | 0m0.078s |
| user | 0m0.074s |
| sys  | 0m0.004s |

#+begin_src bash
  rm countdown{,-v2,-v3}{,.hi,.o}
#+end_src

#+RESULTS:

** 1
#+begin_src haskell :results output
  :{
  subs :: [a] -> [[a]]
  subs []     = [[]]
  subs (x:xs) = yss ++ map (x:) yss
                where yss = subs xs
  :}

  :{
  interleave :: a -> [a] -> [[a]]
  interleave x [] = [[x]]
  interleave x (y:ys) = (x:y:ys) : map (y:) (interleave x ys)
  :}

  :{
  perms :: [a] -> [[a]]
  perms [] = [[]]
  perms (x:xs) = concat (map (interleave x) (perms xs))
  :}

  :{
  choices :: [a] -> [[a]]
  choices (x:xs) = [p | s <- subs (x:xs), p <- perms s]
  :}

  choices [1,2,3]
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[3,2],[1],[1,3],[3,1],[1,2],[2,1],[1,2,3],[2,1,3],[2,3,1],[1,3,2],[3,1,2],[3,2,1]]

Reminder for list comprehensions: a generator can use values generated to its left.

** 2
List $a$ is chosen from list $b$ if the elements of $a$ are a subset of the elements of $b$, assuming that elements don't repeat in either $a$ or $b$.
#+begin_src haskell :results output :noweb yes
  <<choices>>
  :{
  removeFirst el [] = []
  removeFirst el (x:xs) | el == x   = xs
                        | otherwise = x : removeFirst el xs
  :}

  removeFirst 3 [1..10] ++ [3]

  :{
  isChoice :: Eq a => [a] -> [a] -> Bool
  isChoice []     lst = True
  isChoice (x:xs) lst = removeFirst x lst /= lst && isChoice xs lst
  :}

  isChoice [3,2] [1,2,3]
  isChoice [3,4] [1,2,3]
  isChoice [3,4] [1,2,3,4]
  isChoice [1]   []

  let _choices = choices [1,2,3]
  all (\x -> isChoice x [1,2,3]) _choices
#+end_src

#+RESULTS:
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: [1,2,4,5,6,7,8,9,10,3]
: True
: False
: True
: False
: True

** 3
Couldn't come up with a more elegant solution.
#+begin_src haskell :results output :noweb yes
  <<solution>>

  :{
  _split :: [a] -> [([a],[a])]
  _split []     = []
  _split [_]    = []
  _split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- _split xs]
  -- split (x:xs) = ([],(x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
  -- split (x:xs) = [([],(x:xs))] ++ ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  split lst = [([],lst)] ++ (_split lst) ++ [(lst,[])]

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  -- exprs [1,2]
#+end_src

The code block above, with the last line uncommented, does not output a result after a long time and uses a lot of memory, do not run it.

#+begin_example
exprs [1,2,3,4]
= (applying exprs)
[e | (ls, rs) <- split [1,2,3,4],
     l        <- exprs ls,
     r        <- exprs rs,
     e        <- combine l r]
= (applying split)
[([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
= (values of ls)
[[],[1],[1,2],[1,2,3],[1,2,3,4]]
= (values of rs)
[[1,2,3,4],[2,3,4],[3,4],[4],[]]
= (applying exprs ls)
[[], [Val 1],[App Add (Val 1) (Val 2) ...],[1,2,3],[1,2,3,4]]
#+end_example

#+begin_src haskell :results output
[(i,j) | i <- [[],[1],[2,3],[4,5,6]], j <- [[4,5,6],[2,3],[1],[]]]
#+end_src

#+RESULTS:
: [([],[4,5,6]),([],[2,3]),([],[1]),([],[]),([1],[4,5,6]),([1],[2,3]),([1],[1]),([1],[]),([2,3],[4,5,6]),([2,3],[2,3]),([2,3],[1]),([2,3],[]),([4,5,6],[4,5,6]),([4,5,6],[2,3]),([4,5,6],[1]),([4,5,6],[])]

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  [e | l <- [(Val 1)], r <- [(Val 2)], e <- combine l r]
  [e | l <- [(Val 1)], r <- [(Val 2), (Val 3)], e <- combine l r]
  [e | l <- [(Val 1)], r <- [(Val 2), []], e <- combine l r]
#+end_src

#+RESULTS:
#+begin_example
1+(2*3)
[5]
[]
[[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
True
[1+2,1-2,1*2,1/2]
[1+2,1-2,1*2,1/2,1+3,1-3,1*3,1/3]
<interactive>:102:37-38: error:
    • Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
    • In the expression: []
      In the expression: [(Val 2), []]
      In a stmt of a list comprehension: r <- [(Val 2), []]
#+end_example

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  _split :: [a] -> [([a],[a])]
  _split []     = []
  _split [_]    = []
  _split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- _split xs]
  -- split (x:xs) = ([],(x:xs)) : [(x:ls,rs) | (ls,rs) <- split xs]
  -- split (x:xs) = [([],(x:xs))] ++ ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  split lst = [([],lst)] ++ (_split lst) ++ [(lst,[])]

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  -- exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  exprs [1,2]
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True
: *** Exception: stack overflow

#+begin_src haskell :results output :noweb yes
  <<solution>>
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  -- exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  :{
  solutions :: [Int] -> Int -> [Expr]
  solutions ns n =
    [e | ns' <- choices ns, e <- exprs ns', eval e == [n]]
  :}

  exprs [1,2,3]
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: True
: [1+(2+3),1-(2+3),1*(2+3),1/(2+3),1+(2-3),1-(2-3),1*(2-3),1/(2-3),1+(2*3),1-(2*3),1*(2*3),1/(2*3),1+(2/3),1-(2/3),1*(2/3),1/(2/3),(1+2)+3,(1+2)-3,(1+2)*3,(1+2)/3,(1-2)+3,(1-2)-3,(1-2)*3,(1-2)/3,(1*2)+3,(1*2)-3,(1*2)*3,(1*2)/3,(1/2)+3,(1/2)-3,(1/2)*3,(1/2)/3]



The function =split= modified to return pairs containing the empty list wouldn't fit with the other functions since =combine= expects arguments of the type =Expr= and =exprs= cannot output a non-empty list if its input is the empty list. I don't understand why =exprs= does not apply =combine= to the empty list and throws an error before running out of stack memory. Conceptually, I cannot make sense of =split= returning the empty list because then =combine= would return incomplete expressions. =combine= working with incomplete expressions is not necessary in our case because the game requires a predetermined list of numbers, but it could be useful for generalizing our program.

** 4
#+begin_src haskell :results output :noweb yes
  <<eval>>
  <<choices>>
  :{
  split :: [a] -> [([a],[a])]
  split []     = []
  split [_]    = []
  split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]
  :}

  :{
  ops :: [Op]
  ops = [Add,Sub,Mul,Div]
  :}

  :{
  combine :: Expr -> Expr -> [Expr]
  combine l r = [App o l r | o <- ops]
  :}

  :{
  exprs :: [Int] -> [Expr]
  exprs [] = []
  exprs [n] = [Val n]
  exprs ns = [e | (ls, rs) <- split ns,
                  l        <- exprs ls,
                  r        <- exprs rs,
                  e        <- combine l r]
  :}

  allExpressions = concat (map exprs (choices [1,3,7,10,25,50]))
  "number of possible expressions: " ++ show (length allExpressions)
  validExpressions = filter (\x -> x /= []) (map eval allExpressions)
  "number of valid expressions: " ++ show (length validExpressions)
#+end_src

#+RESULTS:
: 1+(2*3)
: [5]
: []
: [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
: number of possible expressions: 33665406
: number of valid expressions: 4672540

* chapter 10
** 1
#+begin_src haskell :compile yes :results output
  myPutStr lst = sequence_ [putChar x | x <- lst]

  main = myPutStr "Hello, World!"
#+end_src

#+RESULTS:
: Hello, World!
** 2
#+begin_src haskell :compile yes :results output
  type Board = [Int]

  putBoardRow :: Int -> Int -> IO ()
  putBoardRow x y = putStrLn ((show x) ++ ": " ++ (replicate y '*'))

  _putBoard :: Int -> Board -> IO ()
  _putBoard n [x]    = putBoardRow n x
  _putBoard n (x:xs) = do putBoardRow n x
                          _putBoard (n + 1) xs

  putBoard :: Board -> IO ()
  putBoard lst = _putBoard 1 lst

  main = do putBoard (reverse [1..10])
            putBoard [1..10]
#+end_src

#+RESULTS:
#+begin_example
1: **********
2: *********
3: ********
4: *******
5: ******
6: *****
7: ****
8: ***
9: **
10: *
1: *
2: **
3: ***
4: ****
5: *****
6: ******
7: *******
8: ********
9: *********
10: **********
#+end_example
** 3
#+begin_src haskell :compile yes :results output
  type Board = [Int]

  putBoard :: Board -> IO ()
  putBoard b = sequence_ [putStrLn ((show x) ++ ": " ++ (replicate y '*')) | (x, y) <- zip [1..] b]

  main = putBoard (reverse [1..10])
#+end_src

#+RESULTS:
#+begin_example
1: **********
2: *********
3: ********
4: *******
5: ******
6: *****
7: ****
8: ***
9: **
10: *
#+end_example
** 4
[[file:adder.hs]]
** 5
[[file:adder-v2.hs]]
** 6
[[file:readLine.hs]]

* chapter 11
** 1
[[file:tictactoe-v3.hs]]
** 2
[[file:tictactoe-v4.hs]]
You can quickly see that the computer chooses different positions by playing positions 0 then 8.
** 3
[[file:tictactoe-v6.hs]]
This AI is dumb. I tried to write a version that checks if a tree can lead to victory, but I couldn't get it to compile:
[[file:tictactoe-v5.hs]]
* chapter 12
** Functors
Functors: class of types that support mapping a function over each element of a data structure. The concept can be represented in Haskell with the following
#+begin_src haskell :eval never
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src
Functors are required to satisfy two equational laws:
#+begin_example
fmap id      = id
fmap (g . h) = fmap g . fmap h
#+end_example
=fmap= preserves the identity function, applying it to the identity function returns the same function.
=fmap= preserves composition, applying it to the composition of two functions gives the same result as applying =fmap= to the two functions separately and them composing.

One implementation of the type class for lists that violates these laws is:
#+begin_src haskell :eval never
instance Functor [] where
   -- fmap :: (a -> b) -> f a -> f b
   fmap g []     = []
   fmap g (x:xs) = fmap g xs ++ [g x]
#+end_src

#+begin_example
> fmap id [1,2]
[2,1]
> id [1,2]
[1,2]
> fmap (not . even) [1,2]
[False,True]
> (fmap not . fmap even) [1,2]
[True,False]
#+end_example

#+begin_src haskell :results output
  :{
  data Tree a = Leaf a | Node (Tree a) (Tree a)
                deriving Show
  :}

  :{
  instance Functor Tree where
    fmap g (Leaf x)   = (Leaf (g x))
    fmap g (Node l r) = (Node (fmap g l) (fmap g r))
  :}

  fmap (1+) (Node (Leaf 1) (Leaf 2))
  fmap length (Node (Leaf "abcd") (Leaf "xyz"))

#+end_src

#+RESULTS:
: Node (Leaf 2) (Leaf 3)
: Node (Leaf 4) (Leaf 3)

#+begin_example
instance Functor IO where
  -- fmap :: (a -> b) -> IO a -> IO b
  fmap g mx = do {x <- mx; return (g x)}
#+end_example
First, the IO operation is done and its result is stored in =x=. Then =g= is applied to =x= and the result is wrapped with the type =IO= with =return=

#+begin_example
fmap show (return True)
#+end_example
=fmap= is applied to =show=, then =True= is wrapped inside a =IO= (?).

#+begin_src haskell :results output
  fmap show (Just 3)
  show (Just 3)
#+end_src

#+RESULTS:
: Just "3"
: Just 3

#+begin_example
ghci> fmap show (Just 3)
Just "3"
ghci> show (Just 3)
"Just 3"
#+end_example

#+begin_example
getStr :: String -> IO String
getStr x = do {y <- getChar; if y == '\n' then (return x) else (getStr (x ++ [y]))}
#+end_example

#+RESULTS:
: Cons 3 (Cons 2 Nil)
: Cons 2 (Cons 1 Nil)
: Cons False (Cons True Nil)
: Cons True (Cons False Nil)

** Applicative Functors
Applicatives generalize functors to functions with any number of arguments.
#+begin_src haskell :eval never
class Functor f => Applicative f where
   pure :: a -> f a
   (<*>) :: f (a -> b) -> f a -> f b
#+end_src

#+begin_example
pure (+1) <*> Just 1
Just (+1) <*> Just 1
fmap (+1) Just 1
Just ((+1) 1)
Just 2
#+end_example

#+begin_example
pure (+) <*> Just 1 <*> Just 2
Just (+) <*> Just 1 <*> Just 2
fmap (+) (Just 1) <*> Just 2
Just (1+) <*> Just 2
fmap (1+) (Just 2)
Just (1+2)
Just 3
#+end_example

#+begin_example
pure (+) <*> Nothing <*> Just 2
Just (+) <*> Nothing <*> Just 2
fmap (+) Nothing <*> Just 2
Nothing <*> Just 2
Nothing
#+end_example

=[a]= can be viewed as a generalization of =Maybe a= that permits multiple results in the case of success. The empty list is a failure and a non-empty list is the list of all possible ways in which a result may succeed.

#+begin_example
(*) <$> [1,2] <*> [3,4]
[(*)] <*> [1,2] <*> [3,4]
[(1*),(2*)] <*> [3,4]
[(1*3),(1*4),(2*)] <*> [3,4]
[(1*3),(1*4),(2*3),(2*4)]
[3,4,6,8]
#+end_example

Applicative functors allows us to write programs in a familiar style that may also have /effects./ The arguments of the application can also fail, succed in more than one way, do IO.

#+begin_src haskell :eval never
sequenceA :: Applicative f => [f a] -> f [a]
sequenceA []     = pure []
sequenceA (x:xs) = pure (:) <*> x <*> sequenceA xs
#+end_src

#+begin_src haskell :eval never
getChars :: Int -> IO String
getChars n = sequenceA (replicate n getChar)
#+end_src

Laws
#+begin_example
pure id <*> x   = x
pure (g x)      = pure g <*> pure x
x <*> pure y    = pure (\g -> g y) <*> x
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z
#+end_example
1. =pure= preserves the identity function
2. =pure= preserves function application
3. When an effectful function is applied to an pure argument, the order in which we evaluate the two components doesn't matter
4. Modulo the types involved, =<*>= associative.

#+begin_example
x <*> (y <*> z) = (pure (.) <*> x <*> y) <*> z
#+end_example

#+begin_example
pure id <*> x = x

pure :: a -> f a
id :: a -> a
<*> :: f (a -> b) -> f a -> f b
x :: f a

pure id :: f (a -> a)
pure id <*> :: f a -> f b
pure id <*> x :: f b
#+end_example

#+begin_example
pure (g x) = pure g <*> pure x

pure :: a -> f a
g :: a -> b
x :: a
<*> :: f (a -> b) -> f a -> f b

pure g :: f (a -> b)
pure x :: f a
pure g <*> :: f a -> f b
pure g <*> pure x :: f b

g x :: b
pure (g x) :: f b
#+end_example

#+begin_example
x <*> pure y = pure (\g -> g y) <*> x

x :: f (a -> b)
<*> :: f (a -> b) -> f a -> f b
pure :: a -> f a
y :: a

x <*> :: f a -> f b
pure y :: f a
x <*> pure y :: f b

(\g -> g y) :: ((c -> b) -> b)
pure (\g -> g y) :: f ((c -> b) -> b)
pure (\g -> g y) <*> :: f (c -> b) -> f b
pure (\g -> g y) <*> x :: f b
x :: f (c -> b)
a :: c -> b
#+end_example

** Monads
#+begin_src haskell :results output
class Applicative m => Monad m where
   return :: a -> m a
   (>>=) :: m a -> (a -> m b) -> m b
   return = pure
#+end_src

Laws
#+begin_example
return x >>= f   = f x
mx >>= return    = mx
(mx >>= f) >>= g = mx >>= (\x -> (f x >>= g))
#+end_example

#+begin_src haskell :results output :compile yes
  type State = Int

  newtype ST a = S (State -> (a,State))

  app :: ST a -> State -> (a,State)
  app (S st) x = st x

  instance Functor ST where
    fmap g st = S (\s -> let (x,s') = app st s in (g x, s'))

  instance Applicative ST where
    pure x = S (\s -> (x,s))
    stf <*> stx = S (\s ->
      let (f,s')  = app stf s
          (x,s'') = app stx s' in (f x, s''))

  instance Monad ST where
    st >>= f = S (\s -> let (x,s') = app st s in app (f x) s')

  data Tree a = Leaf a | Node (Tree a) (Tree a)
                deriving Show

  tree :: Tree Char
  tree = Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')

  rlabel :: Tree a -> Int -> (Tree Int, Int)
  rlabel (Leaf _)   n = (Leaf n, n+1)
  rlabel (Node l r) n = (Node l' r', n'')
    where
      (l',n')  = rlabel l n
      (r',n'') = rlabel r n'


  fresh :: ST Int
  fresh = S (\n -> (n,n+1))

  alabel :: Tree a -> ST (Tree Int)
  alabel (Leaf _)   = Leaf <$> fresh
  alabel (Node l r) = Node <$> alabel l <*> alabel r

  mlabel :: Tree a -> ST (Tree Int)
  mlabel (Leaf _)   = do n <- fresh
                         return (Leaf n)
  mlabel (Node l r) = do l' <- mlabel l
                         r' <- mlabel r
                         return (Node l' r')


  main = do putStr "rlabel: "
            putStrLn (show (rlabel tree 0))
            putStr "alabel: "
            putStrLn (show (app (alabel tree) 0))
            putStr "mlabel: "
            putStrLn (show (app (mlabel tree) 0))
#+end_src

#+RESULTS:
: rlabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)
: alabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)
: mlabel: (Node (Node (Leaf 0) (Leaf 1)) (Leaf 2),3)

#+begin_example
(rlabel tree 0)

(Node l' r', n'')
(l',n')  = rlabel (Node (Leaf 'a') (Leaf 'b')) 0
(r',n'') = rlabel (Leaf 'c') n'

(Node l' r', n'')
(l',n')  = rlabel (Leaf 'a') 0
(r',n'') = rlabel (Leaf 'b') n'

(Leaf 'a') 0 = (Leaf 0, 1)

(Node l' r', n'')
(Leaf 0,1)     = rlabel (Leaf 'a') 0
(r'    ,n'')   = rlabel (Leaf 'b') 1

(Leaf 'b') 1 = (Leaf 1, 2)

(Node l' r', n'')
(Leaf 0,1) = rlabel (Leaf 'a') 0
(Leaf 1,2) = rlabel (Leaf 'b') 1
((Node (Leaf 0) (Leaf 1)),2)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
(r',n'') = rlabel (Leaf 'c') 2

(Leaf 'c') 2 = ((Leaf 2),3)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
(r',n'') = rlabel (Leaf 'c') 2

(Leaf 'c') 2 = ((Leaf 2), 3)

(Node l' r', n'')
((Node (Leaf 0) (Leaf 1)),2)  = ((Node (Leaf 0) (Leaf 1)),2)
((Leaf 2),3)                  = ((Leaf 2), 3)

(Node (Node (Leaf 0) (Leaf 1)) (Leaf 2), 3)
#+end_example

#+begin_example
(app (alabel tree) 0)

(alabel Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c'))

Node <$> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')
pure Node <*> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')
S (\s -> (Node,s)) <*> alabel (Node (Leaf 'a') (Leaf 'b')) <*> alabel (Leaf 'c')

Node <$> alabel (Leaf 'a') <*> alabel (Leaf 'b')
S (\p -> (Node,p) <*> alabel (Leaf 'a') <*> alabel (Leaf 'b'))

alabel (Leaf 'a')
Leaf <$> fresh
S (\q -> (Leaf,q)) <*> fresh
S (\q -> (Leaf,q)) <*> S (\n -> (n, n+1))
S (\a ->
    let (f,a')  = app S (\q -> (Leaf,q)) a
    let (x,a'') = app fresh              a'
      in (f x,a''))
app S (\q -> (Leaf,q)) a = (Leaf,a)
app S (\n -> (n,n+1))  a = (a,a+1)
S (\a -> (Leaf a,a+1))

S (\p -> (Node,p)) <*> S (\a -> (Leaf a,a+1))
S (\a ->
    let (f,a')  = app S (\p -> (Node,p)) a
    let (x,a'') = app S (\b -> (Leaf b,b+1)) a'
      in (f x,a''))
app S (\p -> (Node,p)) a = (Node,a)
app S (\b -> (Leaf b,b+1))) a = (Leaf a,a+1)
S (\a -> ((Node (Leaf a)),a+1))

S (\a -> ((Node (Leaf a)),a+1)) <*> S (\a -> (Leaf a,a+1))
S (\c ->
    let (f,c')  = app S (\a -> ((Node (Leaf a)),a+1)) c
    let (x,c'') = app S (\a -> (Leaf a,a+1))          c'
      in (f x,c''))
app S (\a -> ((Node (Leaf a)),a+1)) c = ((Node (Leaf c)),c+1)
app S (\a -> (Leaf a,a+1)) (c+1) = (Leaf c+1,c+1+1)
S (\c -> ((Node (Leaf c)) (Leaf c+1),c+2))
S (\c -> (Node (Leaf c) (Leaf c+1),c+2))

S (\c -> (Node (Leaf c) (Leaf c+1),c+2)) <*> S (\a -> (Leaf a,a+1))
S (\s -> ((Node (Node (Leaf s) (Leaf s+1)) (Leaf s+2)),s+3))
#+end_example
** exercises
*** 1
#+begin_src haskell :results output
  :{
  data Tree a = Leaf | Node (Tree a) a (Tree a)
                deriving Show
  :}

  :{
  instance Functor Tree where
    -- fmap :: (a -> b) -> Tree a -> Tree b
    fmap _ Leaf         = Leaf
    fmap f (Node l m r) = Node (fmap f l) (f m) (fmap f r)
  :}

  fmap (2^) (Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf))
#+end_src

#+RESULTS:
: Node (Node Leaf 2 Leaf) 4 (Node Leaf 8 Leaf)
*** 2
#+begin_src haskell :results output
  :{
  instance Functor ((->) a) where
    -- fmap :: (a -> b) -> ((->) a) -> ((->) b)
    fmap = 
  :}
#+end_src

#+RESULTS:
: <interactive>:4:10-25: error:
:     Duplicate instance declarations:
:       instance Functor ((->) a) -- Defined at <interactive>:4:10
:       instance Functor ((->) r) -- Defined in ‘GHC.Base’
*** 4
#+begin_src haskell :results output
  newtype ZipList a = Z [a] deriving Show

  :{
  instance Functor ZipList where
    -- fmap :: (a -> b) -> ZipList a -> ZipList b
    fmap g (Z xs) = (Z (map g xs)) : (fmap g (Z xs))
  :}

  -- :{
  -- instance Applicative ZipList where
    -- pure :: a -> ZipList a
    -- pure x = Z x

    -- <*> :: ZipList (a -> b) -> ZipList a -> ZipList b
    -- (Z gs) <*> (Z xs) = 
  -- :}
#+end_src

#+RESULTS:
#+begin_example
<interactive>:8:19-50: error:
    • Couldn't match expected type: ZipList b
                  with actual type: [ZipList b]
    • In the expression: (Z (map g xs)) : (fmap g (Z xs))
      In an equation for ‘fmap’:
          fmap g (Z xs) = (Z (map g xs)) : (fmap g (Z xs))
      In the instance declaration for ‘Functor ZipList’
    • Relevant bindings include
        g :: a -> b (bound at <interactive>:8:8)
        fmap :: (a -> b) -> ZipList a -> ZipList b
          (bound at <interactive>:8:3)

<interactive>:8:45-48: error:
    • Couldn't match type ‘ZipList’ with ‘[]’
      Expected: [a]
        Actual: ZipList a
    • In the second argument of ‘fmap’, namely ‘(Z xs)’
      In the second argument of ‘(:)’, namely ‘(fmap g (Z xs))’
      In the expression: (Z (map g xs)) : (fmap g (Z xs))
#+end_example
